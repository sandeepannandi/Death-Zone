<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEATH ZONE</title>
    <link rel="icon" type="image/png" href="https://cdn.pixabay.com/photo/2022/05/04/17/32/skull-7174522_640.jpg">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet"> <!-- Added Pixel Font -->
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 18px;
            text-shadow: 1px 1px 1px black;
            pointer-events: none;
        }
        #score {
            position: absolute;
            top: 40px;
            right: 20px;
            text-align: right;
            color: white;
            font-size: 18px;
            text-shadow: 1px 1px 1px black;
            pointer-events: none;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin-left: -10px;
            margin-top: -10px;
            color: white;
            font-size: 20px;
            text-align: center;
            pointer-events: none;
        }
        #health {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 1px 1px 1px black;
            pointer-events: none;
        }
        #minimap {
            position: absolute;
            top: 20px;
            left: 5px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 0.3px solid white;
            border-radius: 50%;
            pointer-events: none;
        }
        
        #minimap-canvas {
            position: absolute;
            top: 0px;
            left: 0px;
            width: 150px;
            height: 150px;
            border-radius: 50%;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 48px;
            text-align: center;
            text-shadow: 2px 2px 2px black;
            display: none;
            pointer-events: none;
        }
        #restart {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 10px 20px;
            background-color: rgb(255, 255, 255);
            color: rgb(0, 0, 0);
            font-size: 16px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            display: none;
            transition: background-color 0.3s;
        }
        #restart:hover {
            background-color: #586C53;
            color: white;
        }
        #welcomeScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgb(0, 0, 0);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ff3434;
            z-index: 1000;
        }
        #welcomeContent {
            display: flex; /* Enable flexbox */
            justify-content: space-around; /* Space out left and right */
            align-items: flex-start; /* Align items to the top */
            text-align: center;
            max-width: 90%; /* Use more width */
            width: 1000px; /* Max width */
            padding: 20px;
            gap: 40px; /* Add gap between columns */
        }
        #welcomeLeft {
            flex-basis: 50%; /* Take up 40% of the width */
            display: flex;
            flex-direction: column;
            align-items: center; /* Center title and button */
        }
        #welcomeRight {
            flex-basis: 50%; /* Take up 50% of the width */
            text-align: left; /* Align text to the left */
            color: #4CAF50; /* Green text color */
            font-size: 16px;
            line-height: 1.5;
        }
        #welcomeRight p {
            margin-bottom: 10px; /* Space between paragraphs */
        }
        #welcomeTitle {
            font-family: "Courier New", Courier, monospace; /* Keep blocky font */
            font-size: 8vw; /* Adjust size for title */
            color: #D0E0C8; /* Light green/white like image */
            text-align: center;
            font-weight: bold;
            -webkit-text-stroke: 1px #586C53; /* Add a dark outline */
            text-shadow: 
                0.04em 0.04em 0 #8EAC84, /* Darker green shadow */
                0.08em 0.08em 0 #586C53;  /* Dark grey/green shadow for depth */
            margin-bottom: 30px; /* Space below title */
        }
        
        #startButton {
            padding: 10px 40px;
            font-size: 16px;
            background-color: #ffffff;
            color: rgb(0, 0, 0);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-top: 20px; /* Ensure space above button */
        }
        #startButton:hover {
            background-color: #586C53;
            color: rgb(255, 255, 255);
        }
        /* Remove old .instructions styles */
        .instructions {
            display: none;
        }
        #ammo {
            position: absolute;
            top: 60px;
            right: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 1px 1px 1px black;
            pointer-events: none;
        }
        #grenadeCount {
            position: absolute;
            top: 80px; /* Position below ammo */
            right: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 1px 1px 1px black;
            pointer-events: none;
        }

    #blurOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(100, 100, 100, 0.6); /* Semi-transparent grey */
        backdrop-filter: blur(5px); /* Apply blur effect */
        z-index: 1001; /* Below round text */
        display: none; /* Hidden by default */
    }

    #roundStartText {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: "Courier New", Courier, monospace; /* Keep blocky font */
        font-size: 10vw; /* Slightly larger */
        color: #D0E0C8; /* Light green/white like image */
        text-align: center;
        font-weight: bold;
        -webkit-text-stroke: 1px #586C53; /* Add a dark outline */
        text-shadow: 
            0.04em 0.04em 0 #8EAC84, /* Darker green shadow */
            0.08em 0.08em 0 #586C53;  /* Dark grey/green shadow for depth */
        z-index: 1002; /* Above blur overlay */
        display: none; /* Hidden by default */
        pointer-events: none;
    }

    /* Styles for Round Complete Screen */
    #roundCompleteOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(100, 100, 100, 0.6); /* Semi-transparent grey */
        backdrop-filter: blur(5px); /* Apply blur effect */
        z-index: 1001; /* Below round text */
        display: none; /* Hidden by default */
    }

    #roundCompleteText {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: "Courier New", Courier, monospace; /* Keep blocky font */
        font-size: 10vw; /* Slightly larger */
        color: #D0E0C8; /* Light green/white like image */
        text-align: center;
        font-weight: bold;
        -webkit-text-stroke: 1px #586C53; /* Add a dark outline */
        text-shadow: 
            0.04em 0.04em 0 #8EAC84, /* Darker green shadow */
            0.08em 0.08em 0 #586C53;  /* Dark grey/green shadow for depth */
        z-index: 1002; /* Above blur overlay */
        display: none; /* Hidden by default */
        pointer-events: none;
    }

    #roundCompleteSubText {
        font-family: Arial, sans-serif;
        font-size: 24px; 
        color: #ffffff; 
        text-align: center;
        text-shadow: 1px 1px 2px rgb(34, 34, 34);
        z-index: 1002; 
        pointer-events: none;
    }

        /* New Round Transition Overlay */
        #round-transition-overlay {
            display: none; /* Hidden by default - IMPORTANT! */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(50, 50, 50, 0.7); /* Semi-transparent grey */
            backdrop-filter: blur(5px); /* Blur effect */
            -webkit-backdrop-filter: blur(5px); /* Safari support */
            color: #ccffcc; /* Light green text */
            font-family: 'Press Start 2P', cursive; /* Pixel font */
            text-align: center;
            z-index: 1001; /* Above other UI */
            /* REMOVED duplicate display:flex declaration */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-transform: uppercase; /* Match image style */
        }

        .round-complete-text {
            position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: "Courier New", Courier, monospace; /* Keep blocky font */
        font-size: 10vw; /* Slightly larger */
        color: #D0E0C8; /* Light green/white like image */
        text-align: center;
        font-weight: bold;
        -webkit-text-stroke: 1px #586C53; /* Add a dark outline */
        text-shadow: 
            0.04em 0.04em 0 #8EAC84, /* Darker green shadow */
            0.08em 0.08em 0 #586C53;  /* Dark grey/green shadow for depth */
        z-index: 1002; /* Above blur overlay */
        display: none; /* Hidden by default */
        pointer-events: none;
        }

        .next-round-text {
            font-size: 2.5vw; /* Smaller responsive font size */
             color: #e0ffe0; /* Very light green/almost white */
             text-shadow: 
                2px 2px 0px #507550, /* Lighter shadow */
                4px 4px 0px #334d33; /* Darker shadow */
             -webkit-text-stroke: 1px #1a2e1a; /* Thin dark outline */
             paint-order: stroke fill;
    }
    </style>
</head>
<body>
    <div id="welcomeScreen">
        <div id="welcomeContent">
            <div id="welcomeLeft">
                <h1 id="welcomeTitle">DEATH ZONE</h1>
                <button id="startButton">Let's go</button>
            </div>
            <div id="welcomeRight">
                <p>Movement: WASD keys to walk, hold Shift to run</p>
                <p>Combat: Click to shoot zombies, 1-5 keys to switch weapons</p>
                <p>Grenade: Press 5 to throw a grenade.</p>
                <p>The world is dead. The dead now walk. You're one of the few left breathing, fighting to survive in the ruins of what was. There's a rumor of a safe haven beyond the city. But between you and salvation? Endless hunger and the darkness of those who once lived.</p>
                <p>Run. Fight. Survive.</p>
            </div>
        </div>
    </div>
    <div id="info"></div>
    <div id="score">Score: 0</div>
    <div id="crosshair">+</div>
    <div id="health">Health: 100</div>
    <div id="ammo">Ammo: ∞</div>
    <div id="grenadeCount">Grenades: 0</div> <!-- Grenade Count HUD -->
    <div id="gameOver">WASTED</div>
    <button id="restart">Restart</button>
    <div id="minimap">
        <div id="minimap-title"></div>
        <canvas id="minimap-canvas"></canvas>
    </div>

    <div id="blurOverlay"></div> <!-- Added Blur Overlay -->
    <div id="roundStartText">ROUND 1</div> <!-- Added Round Start Text -->

    <!-- New Round Complete Screen Elements -->
    <div id="roundCompleteOverlay">
        <div id="roundCompleteText">ROUND 1 COMPLETE</div>
        <div id="roundCompleteSubText">Heading to Round 2...</div>
    </div>

    <!-- New Round Transition Overlay -->
    <div id="round-transition-overlay">
        <div class="round-complete-text">ROUND 1 COMPLETE</div>
        <div class="next-round-text">Heading to Round 2...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game state
        let scene, camera, renderer, player, zombies = [];
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isRunning = false; // New variable to track running state
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let score = 0;
        let playerHealth = 100;
        let isGameOver = false;
        let gameStarted = false; // Flag to track if game has started
        let bullets = [];
        let robotLasers = []; // Store robot lasers
        let raycaster = new THREE.Raycaster();
        let gameTime = 0; // Track game time in seconds
        let isNight = false;
        let skybox;
        let sunLight;
        let moonLight;
        let minimapCanvas, minimapCtx;
        let campfire;
        let healingStation;
        let clouds = []; // Store cloud objects
        let birds = []; // Store bird objects
        let sunrays; // Store sunrays object
        let moonrays; // Store moonrays object
        let currentWave = 1; // Track the current wave
        let waveMessage = null; // For displaying wave messages
        let waveMessageTimer = 0; // Timer for wave message display
        let robots = []; // Store robot objects
        let activePowerups = []; // Store active powerups
        let activeGrenades = []; // Store active grenades
        let powerupSpawnTimer = 0; // Timer for powerup spawns
        let grenadeCount = 0; // Player's grenade count
        let bossZombie = null; // Store the boss zombie
        let isBossFight = false; // Flag to track if boss fight is active
        let bossHealthBar = null; // DOM element for boss health bar
        let isJumping = false; // Track if player is currently jumping
        let jumpVelocity = 0;  // Current vertical velocity
        let playerHeight = 1.5; // Default player height
        let gravity = 18;      // Gravity strength
        let currentRound = 1;
        let isTransitioning = false; // To pause game during transition
        
        // Poison system
        let isPoisoned = false; // Track if player is currently poisoned
        let poisonTimeRemaining = 0; // Seconds of poison effect remaining
        let poisonDamageTimer = 0; // Timer for periodic poison damage
        let poisonProjectiles = []; // Store active poison projectiles
        
        // Weapon system
        let currentWeapon = 'pistol'; // Default weapon
        let weaponMessage = null; // For displaying weapon messages
        let weaponMessageTimer = 0; // Timer for weapon message display
        let shotgunAmmo = 100; // Shotgun ammo count
        let sniperAmmo = 10; // Sniper ammo count
        let machineGunAmmo = 400; // Machine gun ammo count
        
        // Scope system
        let isScopeActive = false; // Track scope state
        const SCOPE_ZOOM = 6; // Fixed 6x zoom
        const SCOPE_FOV = 15; // FOV for 6x zoom
        const DEFAULT_FOV = 75; // Default FOV
        let scopeOverlay; // Declare scopeOverlay as a global variable
        
        // Weapon properties
        const weapons = {
            pistol: {
                name: 'Pistol',
                damage: 25,
                range: 100,
                infiniteAmmo: true,
                fireRate: 0.3, // seconds between shots
                lastFired: 0,
                muzzleFlashSize: 100,
                muzzleFlashColor: 'rgba(255,255,0,0.8)',
                bulletSize: 0.1,
                bulletSpeed: 2,
                bulletLifespan: 100
            },
            shotgun: {
                name: 'Shotgun',
                damage: 30,
                range: 50,
                infiniteAmmo: false,
                ammo: 100,
                pellets: 5, // Number of pellets per shot
                spread: 0.1, // Spread of pellets
                fireRate: 1, // seconds between shots
                lastFired: 0,
                muzzleFlashSize: 100,
                muzzleFlashColor: 'rgba(255,200,0,0.9)',
                bulletSize: 0.08,
                bulletSpeed: 2.5,
                bulletLifespan: 50
            },
            sniper: {
                name: 'Sniper',
                damage: 100,
                range: 300,
                infiniteAmmo: false,
                ammo: 20,
                fireRate: 1.8, // seconds between shots
                lastFired: 0,
                muzzleFlashSize: 80,
                muzzleFlashColor: 'rgba(200,255,200,0.7)',
                bulletSize: 0.05,
                bulletSpeed: 5,
                bulletLifespan: 200
            },
            machineGun: {
                name: 'Machine Gun',
                damage: 20,
                range: 150,
                infiniteAmmo: false,
                ammo: 400,
                fireRate: 0.05, // Very fast fire rate (20 rounds per second)
                lastFired: 0,
                muzzleFlashSize: 120,
                muzzleFlashColor: 'rgba(255,165,0,0.9)',
                bulletSize: 0.08,
                bulletSpeed: 3,
                bulletLifespan: 80,
                spread: 0.05 // Small spread for machine gun
            }
        };
        
        // Audio elements
        let audioContext;
        let gunShotSound;
        let footstepSound;
        let grenadeSound; // Added variable for grenade explosion sound
        let lastFootstepTime = 0;
        const FOOTSTEP_INTERVAL = 350; // milliseconds between footstep sounds
        let isMoving = false;
        
        // Initialize the game
        function init() {
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Set sky blue color
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.5; // Player height
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Create lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            // Sun light (always on)
            sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);
            
            // Create visible sun
            const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 1
            });
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.copy(sunLight.position);
            scene.add(sunMesh);
            
            // Moon light (night)
            moonLight = new THREE.DirectionalLight(0x4040ff, 0.3);
            moonLight.position.set(-50, 100, -50);
            moonLight.castShadow = true;
            moonLight.shadow.mapSize.width = 2048;
            moonLight.shadow.mapSize.height = 2048;
            moonLight.visible = false;
            scene.add(moonLight);
            
            // Create visible moon
            const moonGeometry = new THREE.SphereGeometry(8, 32, 32);
            const moonMaterial = new THREE.MeshBasicMaterial({
                color: 0xaaaaff,
                emissive: 0xaaaaff,
                emissiveIntensity: 0.5
            });
            const moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
            moonMesh.position.copy(moonLight.position);
            moonMesh.visible = false;
            scene.add(moonMesh);
            
            // Create moonrays
            moonrays = createMoonrays();
            moonrays.visible = false;
            scene.add(moonrays);
            
            // Store references to sun and moon for day/night cycle
            skybox = {
                sun: sunMesh,
                moon: moonMesh,
                dayColor: new THREE.Color(0x87CEEB),  // Sky blue
                nightColor: new THREE.Color(0x000033) // Dark blue
            };
            
            // Create sunrays
            sunrays = createSunrays();
            scene.add(sunrays);
            
            // Create clouds
            for (let i = 0; i < 4; i++) {
                const cloud = createCloud();
                cloud.position.set(
                    Math.random() * 500 - 250,
                    100 + Math.random() * 40,
                    Math.random() * 500 - 250
                );
                cloud.userData = {
                    speed: 0.05 + Math.random() * 0.1,
                    direction: new THREE.Vector3(Math.random() * 2 - 1, 0, Math.random() * 2 - 1).normalize()
                };
                scene.add(cloud);
                clouds.push(cloud);
            }
            
            // Create birds
            for (let i = 0; i < 3; i++) {
                const bird = createBird();
                bird.position.set(
                    Math.random() * 400 - 200,
                    150 + Math.random() * 50,
                    Math.random() * 400 - 200
                );
                bird.userData = {
                    speed: 0.3 + Math.random() * 0.2,
                    direction: new THREE.Vector3(Math.random() * 2 - 1, 0, Math.random() * 2 - 1).normalize(),
                    wingPhase: Math.random() * Math.PI * 2,
                    wingSpeed: 0.15 + Math.random() * 0.1
                };
                scene.add(bird);
                birds.push(bird);
            }
            
            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x6B8E23, 
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add mountain range
            function createMountainRange() {
                const mountainGroup = new THREE.Group();
                
                // Create several mountains - positioned much farther away
                const mountainCount = 3; // More mountains for a wider range
                const mountainPositions = [
                    { x: -500, z: -700, scale: 4.0 },
                    { x: -400, z: -750, scale: 3.5 },
                    { x: -300, z: -720, scale: 5.0 },
                    { x: -150, z: -680, scale: 3.8 },
                    { x: 0, z: -750, scale: 4.5 },
                    { x: 150, z: -700, scale: 3.7 },
                    { x: 300, z: -730, scale: 4.2 },
                    { x: 450, z: -680, scale: 3.9 }
                ];
                
                for (let i = 0; i < mountainCount; i++) {
                    const mountain = createLowPolyMountain(mountainPositions[i].scale);
                    mountain.position.set(
                        mountainPositions[i].x,
                        0, // Base at ground level
                        mountainPositions[i].z
                    );
                    mountainGroup.add(mountain);
                }
                
                scene.add(mountainGroup);
            }
            
            function createLowPolyMountain(scale = 1.0) {
                const mountainGroup = new THREE.Group();

                const baseHeight = 120 * scale;
                const baseRadius = 80 * scale;
                const segments = 32; // Keep increased segments for smoother cone
                const heightSegments = 10;

                // Use CylinderGeometry with more segments
                const bodyGeometry = new THREE.CylinderGeometry(0, baseRadius, baseHeight, segments, heightSegments, false);

                // --- Vertex Displacement (Reduced) and Coloring ---
                const vertices = bodyGeometry.attributes.position;
                const colors = []; // Array to hold color values per vertex
                const snowLine = baseHeight * (0.6 + Math.random() * 0.2);
                const treeLine = baseHeight * (0.2 + Math.random() * 0.1);

                const rockColor1 = new THREE.Color(0x8c7e75);
                const rockColor2 = new THREE.Color(0x6b5d55);
                const snowColor = new THREE.Color(0xffffff);
                const tempColor = new THREE.Color();

                const position = new THREE.Vector3();
                // Reduced noise parameters to maintain cone shape
                const noiseStrength = baseRadius * 0.02; // Significantly reduced strength

                for (let i = 0; i < vertices.count; i++) {
                    position.fromBufferAttribute(vertices, i);
                    const y = position.y;
                    const normalizedHeight = y / baseHeight;

                    // --- Displacement (Simplified) ---
                    // Apply only very subtle horizontal displacement, preserving cone shape
                    let finalX = position.x;
                    let finalY = position.y;
                    let finalZ = position.z;

                    // Don't displace the very top vertex to keep the point sharp
                    if (normalizedHeight < 0.98) {
                        const horizontalDisplacement = (Math.random() - 0.5) * noiseStrength * (1 - normalizedHeight);
                        // Calculate direction vector away from center axis
                        const dir = new THREE.Vector3(position.x, 0, position.z).normalize();
                        finalX += dir.x * horizontalDisplacement;
                        finalZ += dir.z * horizontalDisplacement;
                        // Very slight vertical jitter
                        finalY += (Math.random() - 0.5) * noiseStrength * 0.1;
                    }

                    vertices.setXYZ(i, finalX, finalY, finalZ);

                    // --- Coloring based on height (Keep this logic) ---
                    let r, g, b;
                    if (y > snowLine) {
                        // Blend from rock color to snow color near the snow line
                        const snowBlend = Math.min(1.0, (y - snowLine) / (baseHeight * 0.15));
                        tempColor.lerpColors(rockColor1, snowColor, snowBlend);
                        r = tempColor.r;
                        g = tempColor.g;
                        b = tempColor.b;
                    } else if (y > treeLine) {
                        // Mid-section: Mix rock colors
                        // Use a simpler height-based blend for rock variation on the cone
                        const rockMix = (y - treeLine) / (snowLine - treeLine);
                        tempColor.lerpColors(rockColor2, rockColor1, rockMix);
                        r = tempColor.r;
                        g = tempColor.g;
                        b = tempColor.b;
                    } else {
                        // Lower area: Darker rock/dirt color
                        r = rockColor2.r;
                        g = rockColor2.g;
                        b = rockColor2.b;
                    }
                    colors.push(r, g, b); // Add color components to the array
                }

                // Add the calculated vertex colors as an attribute to the geometry
                bodyGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                bodyGeometry.computeVertexNormals(); // Recalculate normals after displacement

                // Create the mountain material using vertex colors and smoother shading
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    vertexColors: true,
                    roughness: 0.85,
                    metalness: 0.1
                });

                const mountainBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
                mountainBody.receiveShadow = true;
                mountainGroup.add(mountainBody);

                // --- Sub-peaks (apply similar simplifications) ---
                if (scale > 2.0) {
                    const subpeakCount = Math.floor(Math.random() * 3) + 2;
                    for (let i = 0; i < subpeakCount; i++) {
                        const subpeakScale = scale * (Math.random() * 0.3 + 0.2);
                        const subpeakHeight = 100 * subpeakScale;
                        const subpeakRadius = 60 * subpeakScale;
                        const subSegments = 24;
                        const subHeightSegments = 8;

                        const subpeakGeometry = new THREE.CylinderGeometry(0, subpeakRadius, subpeakHeight, subSegments, subHeightSegments, false);
                        const subVertices = subpeakGeometry.attributes.position;
                        const subColors = [];
                        const subSnowLine = subpeakHeight * (0.6 + Math.random() * 0.2);
                        const subTreeLine = subpeakHeight * (0.2 + Math.random() * 0.1);
                        const subNoiseStrength = subpeakRadius * 0.02; // Reduced strength for subpeaks

                        for (let j = 0; j < subVertices.count; j++) {
                            position.fromBufferAttribute(subVertices, j);
                            const y = position.y;
                            const normalizedHeight = y / subpeakHeight;

                            // Displacement (Simplified for subpeaks)
                            let finalX = position.x;
                            let finalY = position.y;
                            let finalZ = position.z;
                            if (normalizedHeight < 0.98) {
                                const horizontalDisplacement = (Math.random() - 0.5) * subNoiseStrength * (1 - normalizedHeight);
                                const dir = new THREE.Vector3(position.x, 0, position.z).normalize();
                                finalX += dir.x * horizontalDisplacement;
                                finalZ += dir.z * horizontalDisplacement;
                                finalY += (Math.random() - 0.5) * subNoiseStrength * 0.1;
                            }
                            subVertices.setXYZ(j, finalX, finalY, finalZ);

                            // Coloring (Keep similar logic)
                            let r, g, b;
                            if (y > subSnowLine) {
                                const snowBlend = Math.min(1.0, (y - subSnowLine) / (subpeakHeight * 0.15));
                                tempColor.lerpColors(rockColor1, snowColor, snowBlend);
                                r = tempColor.r; g = tempColor.g; b = tempColor.b;
                            } else if (y > subTreeLine) {
                                const rockMix = (y - subTreeLine) / (subSnowLine - subTreeLine);
                                tempColor.lerpColors(rockColor2, rockColor1, rockMix);
                                r = tempColor.r; g = tempColor.g; b = tempColor.b;
                            } else {
                                r = rockColor2.r; g = rockColor2.g; b = rockColor2.b;
                            }
                            subColors.push(r, g, b);
                        }

                        subpeakGeometry.setAttribute('color', new THREE.Float32BufferAttribute(subColors, 3));
                        subpeakGeometry.computeVertexNormals();

                        const subpeak = new THREE.Mesh(subpeakGeometry, bodyMaterial); // Use the same vertex color material

                        const angle = Math.random() * Math.PI * 2;
                        const distance = baseRadius * (0.4 + Math.random() * 0.3);
                        subpeak.position.set(
                            Math.cos(angle) * distance,
                            0,
                            Math.sin(angle) * distance
                        );
                        subpeak.receiveShadow = true;
                        mountainGroup.add(subpeak);
                    }
                }

                return mountainGroup;
            }
            
            // Create the mountain range
            createMountainRange();

            // Add watchtowers
            const tower1 = createWatchTower();
            tower1.position.set(-60, 0, 40); // Position the first tower
            scene.add(tower1);

            const tower2 = createWatchTower();
            tower2.position.set(70, 0, -50); // Position the second tower (distant)
            scene.add(tower2);
            
            // Add campfire healing station
            function createCampfire(position) {
                const campfireGroup = new THREE.Group();
                
                // Create wooden logs in circular arrangement
                const logCount = 8;
                const logRadius = 2.0;
                
                for (let i = 0; i < logCount; i++) {
                    const angle = (i / logCount) * Math.PI * 2;
                    
                    // Create log with rounded ends
                    const logLength = 2.0;
                    const logRadius = 0.2;
                    const logGeometry = new THREE.CylinderGeometry(logRadius, logRadius, logLength, 8);
                    const logMaterial = new THREE.MeshStandardMaterial({
                        color: 0x8B4513, // Brown wood color
                        roughness: 1.0,
                        metalness: 0.1
                    });
                    
                    const log = new THREE.Mesh(logGeometry, logMaterial);
                    
                    // Position log in circle, slightly angled inward
                    log.position.set(
                        Math.cos(angle) * 1.2,
                        0.3, // Slightly above ground
                        Math.sin(angle) * 1.2
                    );
                    
                    // Rotate log to point toward center and tilt
                    log.rotation.y = angle + Math.PI / 2;
                    log.rotation.z = Math.PI / 12; // Slight tilt upward
                    
                    campfireGroup.add(log);
                    
                    // Add disc-shaped end caps to logs
                    const endCapGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 8);
                    const endCapMaterial = new THREE.MeshStandardMaterial({
                        color: 0x5D4037, // Darker brown for end grain
                        roughness: 1.0,
                        metalness: 0.0
                    });
                    
                    // Add end caps to both ends of the log
                    const endCap1 = new THREE.Mesh(endCapGeometry, endCapMaterial);
                    endCap1.position.set(
                        Math.cos(angle) * 1.2 + Math.sin(angle) * (logLength/2 - 0.05),
                        0.3 + Math.sin(Math.PI / 12) * (logLength/2 - 0.05),
                        Math.sin(angle) * 1.2 - Math.cos(angle) * (logLength/2 - 0.05)
                    );
                    endCap1.rotation.y = angle + Math.PI / 2;
                    endCap1.rotation.z = Math.PI / 12;
                    
                    const endCap2 = new THREE.Mesh(endCapGeometry, endCapMaterial);
                    endCap2.position.set(
                        Math.cos(angle) * 1.2 - Math.sin(angle) * (logLength/2 - 0.05),
                        0.3 - Math.sin(Math.PI / 12) * (logLength/2 - 0.05),
                        Math.sin(angle) * 1.2 + Math.cos(angle) * (logLength/2 - 0.05)
                    );
                    endCap2.rotation.y = angle + Math.PI / 2;
                    endCap2.rotation.z = Math.PI / 12;
                    
                    campfireGroup.add(endCap1);
                    campfireGroup.add(endCap2);
                }
                
                // Create glowing orange cubes for the fire
                const fireGroup = new THREE.Group();
                const cubeCount = 15;
                
                for (let i = 0; i < cubeCount; i++) {
                    const cubeSize = 0.2 + Math.random() * 0.3;
                    const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
                    
                    // Random orange-yellow color
                    const hue = 0.05 + Math.random() * 0.08; // Orange to yellow hue range
                    const fireColor = new THREE.Color().setHSL(hue, 1.0, 0.5 + Math.random() * 0.5);
                    
                    const cubeMaterial = new THREE.MeshBasicMaterial({
                        color: fireColor,
                        emissive: fireColor,
                        emissiveIntensity: 1.0 + Math.random() * 2.0
                    });
                    
                    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                    
                    // Position cube randomly within the fire area
                    const cubeRadius = Math.random() * 0.8;
                    const cubeAngle = Math.random() * Math.PI * 2;
                    const cubeHeight = 0.5 + Math.random() * 1.5;
                    
                    cube.position.set(
                        Math.cos(cubeAngle) * cubeRadius,
                        cubeHeight,
                        Math.sin(cubeAngle) * cubeRadius
                    );
                    
                    // Random rotation
                    cube.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    
                    // Store original height and other animation data
                    cube.userData = {
                        originalHeight: cubeHeight,
                        floatSpeed: 0.2 + Math.random() * 0.5,
                        rotationSpeed: 0.01 + Math.random() * 0.03,
                        phase: Math.random() * Math.PI * 2
                    };
                    
                    fireGroup.add(cube);
                }
                
                campfireGroup.add(fireGroup);
                campfireGroup.userData = { isCampfire: true, fireGroup: fireGroup };
                
                // Add point light for the fire glow
                const fireLight = new THREE.PointLight(0xff8800, 2, 10);
                fireLight.position.set(0, 1.5, 0);
                fireLight.castShadow = true;
                campfireGroup.add(fireLight);
                
                // Position the entire campfire
                campfireGroup.position.copy(position);
                
                return campfireGroup;
            }
            
            // Add a campfire to the scene
            const campfirePosition = new THREE.Vector3(20, 0, 20);
            campfire = createCampfire(campfirePosition);
            scene.add(campfire);
            
            // Store campfire for later use
            healingStation = {
                position: campfirePosition,
                radius: 5, // Healing radius
                healAmount: 4, // Health per second
                object: campfire
            };
            
            // Add detailed grass elements
            function createGrassClump(size = 1.0) {
                const grassGroup = new THREE.Group();
                
                // Create multiple grass blades for each clump
                const bladeCount = Math.floor(Math.random() * 5) + 8;
                
                for (let i = 0; i < bladeCount; i++) {
                    // Create tapered blade shape
                    const bladeHeight = (Math.random() * 0.2 + 0.1) * size;
                    const bottomWidth = 0.05 * size;
                    const topWidth = 0.01 * size;
                    
                    const bladeGeometry = new THREE.BufferGeometry();
                    const vertices = new Float32Array([
                        // Left side
                        -bottomWidth/2, 0, 0,
                        -topWidth/2, bladeHeight, 0,
                        bottomWidth/2, 0, 0,
                        
                        // Right side
                        bottomWidth/2, 0, 0,
                        -topWidth/2, bladeHeight, 0,
                        topWidth/2, bladeHeight, 0
                    ]);
                    
                    bladeGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                    bladeGeometry.computeVertexNormals();
                    
                    // Vary the grass colors slightly
                    const greenShade = Math.random() * 0.15 + 0.35;
                    const blade = new THREE.Mesh(
                        bladeGeometry,
                        new THREE.MeshStandardMaterial({
                            color: new THREE.Color(0.2, greenShade, 0.1),
                            side: THREE.DoubleSide,
                            flatShading: true
                        })
                    );
                    
                    // Position and rotate blade within the clump
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 0.1 * size;
                    blade.position.set(
                        Math.cos(angle) * radius,
                        0,
                        Math.sin(angle) * radius
                    );
                    
                    // Random rotation and slight curve
                    blade.rotation.y = Math.random() * Math.PI * 2;
                    blade.rotation.x = Math.random() * 0.2;
                    
                    // Add small random offset
                    blade.position.y += Math.random() * 0.01;
                    
                    grassGroup.add(blade);
                }
                
                return grassGroup;
            }
            
            // Create bushes with bulbous shapes similar to trees but smaller
            function createBush(size = 1) {
                const bushGroup = new THREE.Group();
                const bushColor = 0x228B22; // Forest green

                // Create multiple sphere geometries for a clumpy bush look
                const numClumps = 5 + Math.floor(Math.random() * 3); // 5 to 7 clumps
                const clumpMaterial = new THREE.MeshStandardMaterial({
                    color: bushColor,
                    roughness: 0.9,
                    metalness: 0.1,
                    flatShading: false // Smoother look
                });

                for (let i = 0; i < numClumps; i++) {
                    const clumpSize = size * (0.4 + Math.random() * 0.4); // More variation
                    const segments = 12 + Math.floor(Math.random() * 5); // Increased segments (12-16)
                    const geometry = new THREE.SphereGeometry(clumpSize, segments, segments);

                    // Apply more pronounced random deformation for organic look
                    const positions = geometry.attributes.position;
                    const vertex = new THREE.Vector3();
                    const displacementFactor = 0.2 * clumpSize; // More noticeable displacement
                    for (let j = 0; j < positions.count; j++){
                        vertex.fromBufferAttribute(positions, j);
                        vertex.x += (Math.random() - 0.5) * displacementFactor;
                        vertex.y += (Math.random() - 0.5) * displacementFactor * 0.8; // Less vertical displacement
                        vertex.z += (Math.random() - 0.5) * displacementFactor;
                        positions.setXYZ(j, vertex.x, vertex.y, vertex.z);
                    }
                    geometry.computeVertexNormals(); // Recalculate normals

                    const clump = new THREE.Mesh(geometry, clumpMaterial);

                    // Position clumps randomly within the bush area
                    clump.position.x = (Math.random() - 0.5) * size * 0.6;
                    clump.position.y = clumpSize * 0.4 + (Math.random() - 0.5) * size * 0.1; // Slightly elevated base
                    clump.position.z = (Math.random() - 0.5) * size * 0.6;
                    clump.castShadow = true;
                    bushGroup.add(clump);
                }

                return bushGroup;
            }
            
            // Add grass patches throughout the scene
            for (let i = 0; i < 800; i++) {
                const grass = createGrassClump(Math.random() * 1.5 + 1.0);
                
                // Position grass
                grass.position.x = Math.random() * 200 - 100;
                grass.position.z = Math.random() * 200 - 100;
                
                // Add small random rotation
                grass.rotation.y = Math.random() * Math.PI * 2;
                
                // Don't place grass too close to player
                if (grass.position.length() < 5) continue;
                
                scene.add(grass);
            }
            
            // Add bushes throughout the scene
            for (let i = 0; i < 60; i++) { // Reduced from 120 to 60
                const bush = createBush(Math.random() * 1.0 + 0.6); // Reduced size range (was 0.8 to 2.3, now 0.6 to 1.6)
                
                // Position bush
                bush.position.x = Math.random() * 200 - 100;
                bush.position.z = Math.random() * 200 - 100;
                
                // Add small random rotation
                bush.rotation.y = Math.random() * Math.PI * 2;
                
                // Don't place bushes too close to player
                if (bush.position.length() < 8) continue;
                
                scene.add(bush);
            }
            
            // Add trees
            function createStylizedTree(size = 1) { // Removed foliageColor parameter
                const treeGroup = new THREE.Group();
                const trunkColor = 0x8B4513; // Consistent reddish-brown

                // Create trunk (slightly thicker, more segments)
                const trunkHeight = 1.8 * size;
                const trunkRadius = 0.15 * size;
                const trunkSegments = 12; // Increased segments
                const trunkGeometry = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, trunkSegments);
                // Add slight vertex noise to trunk
                const trunkPositions = trunkGeometry.attributes.position;
                const trunkVertex = new THREE.Vector3();
                const trunkDisplacement = trunkRadius * 0.05;
                for (let i = 0; i < trunkPositions.count; i++) {
                    // Only displace horizontally
                    if (Math.abs(trunkPositions.getY(i)) < trunkHeight / 2 * 0.95) { // Avoid top/bottom caps
                         trunkVertex.fromBufferAttribute(trunkPositions, i);
                         trunkVertex.x += (Math.random() - 0.5) * trunkDisplacement;
                         trunkVertex.z += (Math.random() - 0.5) * trunkDisplacement;
                         trunkPositions.setXYZ(i, trunkVertex.x, trunkVertex.y, trunkVertex.z);
                    }
                }
                trunkGeometry.computeVertexNormals();

                const trunkMaterial = new THREE.MeshStandardMaterial({
                    color: trunkColor,
                    roughness: 0.8,
                    metalness: 0.1,
                    flatShading: false // Smoother shading
                });

                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = trunkHeight / 2;
                trunk.castShadow = true;
                treeGroup.add(trunk);

                // Create specific branches based on the image (more segments)
                const branchMaterial = trunkMaterial; // Use same material for branches
                const branchSegments = 8; // Increased segments
                const branchPoints = [
                    { y: 0.6, angle: 0.5, length: 0.7, thickness: 0.7 },
                    { y: 0.7, angle: -0.8, length: 0.8, thickness: 0.8 },
                    { y: 0.8, angle: 3.0, length: 0.6, thickness: 0.6 }
                ];

                branchPoints.forEach(bp => {
                    const branchLength = bp.length * size;
                    const branchThickness = trunkRadius * bp.thickness * 0.6;
                    const branchGeometry = new THREE.CylinderGeometry(branchThickness * 0.7, branchThickness, branchLength, branchSegments);
                    const branch = new THREE.Mesh(branchGeometry, branchMaterial);

                    // Position branch origin on the trunk
                    const startY = trunkHeight * bp.y;
                    branch.position.y = startY;

                    // Apply rotation to angle the branch outwards and upwards
                    const upwardAngle = Math.PI / 4; // Angle branches upwards slightly
                    const quaternionY = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), bp.angle);
                    const quaternionX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), upwardAngle);
                    branch.quaternion.multiplyQuaternions(quaternionY, quaternionX);

                    // Translate the branch along its new axis so the base connects to the trunk
                    branch.translateY(branchLength / 2);
                    branch.castShadow = true;
                    treeGroup.add(branch);

                    // Add foliage to the end of the branch
                    const foliageSize = size * (0.5 + Math.random() * 0.2); // Slightly varied foliage size
                    const foliage = createBulbousFoliage(foliageSize); // Use updated foliage function

                    // Calculate foliage position at the tip of the branch
                    const endPoint = new THREE.Vector3(0, branchLength / 2 + foliageSize * 0.2, 0); // Adjust offset slightly
                    endPoint.applyQuaternion(branch.quaternion);
                    foliage.position.copy(branch.position).add(endPoint);

                    treeGroup.add(foliage);
                });

                // Optional: Add a central foliage cluster if desired (comment out if not needed)
                // const centralFoliage = createBulbousFoliage(size * 0.8);
                // centralFoliage.position.y = trunkHeight * 0.95;
                // treeGroup.add(centralFoliage);

                return treeGroup;
            }

            function createBulbousFoliage(size = 1) {
                // Use SphereGeometry for smoother look, more segments
                const segments = 10 + Math.floor(Math.random() * 5); // Increased segments (10-14)
                const geometry = new THREE.SphereGeometry(size * 0.6, segments, segments);

                // Apply more pronounced random deformation for organic look
                const positions = geometry.attributes.position;
                const vertex = new THREE.Vector3();
                const displacementFactor = 0.15 * size; // Increased displacement
                for (let i = 0; i < positions.count; i++){
                    vertex.fromBufferAttribute(positions, i);
                    const noiseFactor = 1.0 + (Math.random() - 0.5) * 0.5; // Add noise factor
                    vertex.normalize().multiplyScalar(size * 0.6 * noiseFactor); // Displace along normal

                    vertex.x += (Math.random() - 0.5) * displacementFactor * 0.5; // Add smaller random jitter
                    vertex.y += (Math.random() - 0.5) * displacementFactor * 0.5;
                    vertex.z += (Math.random() - 0.5) * displacementFactor * 0.5;
                    positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }

                geometry.computeVertexNormals(); // Recalculate normals after deformation

                // Consistent green color like the image, slightly darker maybe
                const color = new THREE.Color(0x55aa55); // Slightly adjusted green

                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    flatShading: false, // Smoother shading
                    roughness: 0.8,
                    metalness: 0.1
                });

                const foliage = new THREE.Mesh(geometry, material);
                foliage.castShadow = true;

                return foliage;
            }
            
            // Create 50 trees with different sizes and variations
            for (let i = 0; i < 50; i++) {
                // Determine tree type/size
                const treeSize = Math.random() * 1.5 + 0.8;
                
                // Removed foliageColor selection - using consistent color now
                const tree = createStylizedTree(treeSize);
                
                // Position tree in the world
                tree.position.x = Math.random() * 200 - 100;
                tree.position.z = Math.random() * 200 - 100;
                
                // Don't place trees too close to the player
                if (tree.position.length() < 10) continue;
                
                // Add small random rotation
                tree.rotation.y = Math.random() * Math.PI * 2;
                
                scene.add(tree);
            }
            
            // Add rocks
            // Create custom rock geometry using displaced sphere for more realism
            function createCustomRockGeometry(radius = 1, detail = 1) {
                // Start with a sphere
                const segments = 8 + Math.floor(detail * 8); // More segments for more detail (8-16)
                const geometry = new THREE.SphereGeometry(radius, segments, segments);

                // Apply random vertex displacement for a rocky look
                const positions = geometry.attributes.position;
                const vertex = new THREE.Vector3();
                const displacementFactor = radius * (0.2 + Math.random() * 0.3); // More significant displacement (20-50% of radius)

                for (let i = 0; i < positions.count; i++) {
                    vertex.fromBufferAttribute(positions, i);

                    // Displace vertices outwards/inwards randomly along their normal
                    const noiseFactor = 1.0 + (Math.random() - 0.5) * displacementFactor / radius;
                    vertex.normalize().multiplyScalar(radius * noiseFactor);

                    // Add some smaller axis-aligned jitter
                    vertex.x += (Math.random() - 0.5) * displacementFactor * 0.2;
                    vertex.y += (Math.random() - 0.5) * displacementFactor * 0.2;
                    vertex.z += (Math.random() - 0.5) * displacementFactor * 0.2;

                    // Flatten the bottom slightly
                    if (vertex.y < 0) {
                         vertex.y *= 0.5 + Math.random() * 0.2; // Reduce y for vertices below origin
                    }

                    positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }

                geometry.computeVertexNormals(); // Important after displacement
                return geometry;
            }

            const rockMaterial = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                roughness: 0.85, // Slightly rougher
                metalness: 0.15 // Slightly less metallic
                // Consider adding a normal map here later for more detail
            });

            for (let i = 0; i < 50; i++) {
                const rockRadius = 0.6 + Math.random() * 1.0; // Reduced size range (was 0.8 to 2.0, now 0.6 to 1.6)
                const rockDetail = Math.random(); // Random detail level
                const rockGeometry = createCustomRockGeometry(rockRadius, rockDetail); // Generate the geometry
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);

                rock.position.x = Math.random() * 200 - 100;
                rock.position.z = Math.random() * 200 - 100;
                rock.position.y = 0; // Rocks sit on the ground

                // Random scale for variation - applied AFTER geometry generation
                const scale = 0.8 + Math.random() * 0.6; // Smaller overall scale range
                rock.scale.set(scale * (0.8 + Math.random()*0.4), scale * (0.6 + Math.random()*0.4), scale * (0.8 + Math.random()*0.4)); // Non-uniform scaling

                // Random rotation
                rock.rotation.x = Math.random() * Math.PI * 0.1; // Slight tilt
                rock.rotation.y = Math.random() * Math.PI * 2;
                rock.rotation.z = Math.random() * Math.PI * 0.1; // Slight tilt

                // Don't place rocks too close to the player
                if (rock.position.length() < 10) continue;

                rock.castShadow = true; // Rocks should cast shadows
                scene.add(rock);
            }
            
            // Pointer lock controls for mouse movement
            document.addEventListener('click', function(event) {
                if (!document.pointerLockElement) {
                    document.body.requestPointerLock();
                }
            });
            
            document.addEventListener('mousemove', onMouseMove);
            
            // Create a separate click handler for shooting
            document.addEventListener('click', function(event) {
                if (document.pointerLockElement === document.body) {
                    shoot();
                }
            });
            
            // Key controls
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start button handler
            document.getElementById('startButton').addEventListener('click', function() {
                console.log('Start button clicked!');
                startGame();
            });
            
            // Initial zombies (Moved to startGame function)
            // for (let i = 0; i < 5; i++) {
            //     spawnZombie(false); // Only spawn small zombies in wave 1
            // }
            
            // Restart button
            document.getElementById('restart').addEventListener('click', restartGame);
            
            // Initialize minimap
            minimapCanvas = document.getElementById('minimap-canvas');
            minimapCtx = minimapCanvas.getContext('2d');
            minimapCanvas.width = 140;
            minimapCanvas.height = 140;
            
            // Initialize the environment after setting up the scene
            
            // Initialize audio
            initializeAudio();
            
            // Add ammo display if it doesn't exist
            if (!document.getElementById('ammo')) {
                const ammoDisplay = document.createElement('div');
                ammoDisplay.id = 'ammo';
                ammoDisplay.style.position = 'absolute';
                ammoDisplay.style.top = '60px';
                ammoDisplay.style.right = '20px';
                ammoDisplay.style.color = 'white';
                ammoDisplay.style.fontSize = '18px';
                ammoDisplay.style.textShadow = '1px 1px 1px black';
                ammoDisplay.style.pointerEvents = 'none';
                ammoDisplay.textContent = 'Ammo: ∞';
                document.body.appendChild(ammoDisplay);
            }

            // Create scope overlay
            scopeOverlay = document.createElement('div');
            scopeOverlay.style.position = 'absolute';
            scopeOverlay.style.top = '0';
            scopeOverlay.style.left = '0';
            scopeOverlay.style.width = '100%';
            scopeOverlay.style.height = '100%';
            scopeOverlay.style.backgroundImage = 'radial-gradient(circle, transparent 0%, rgba(0,0,0,0.8) 100%)';
            scopeOverlay.style.pointerEvents = 'none';
            scopeOverlay.style.zIndex = '999';
            scopeOverlay.style.display = 'none';
            document.body.appendChild(scopeOverlay);
            startRound(1);
        }
        
        // Initialize audio system
        function initializeAudio() {
            // Create audio context
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Ensure context is running
                if (audioContext.state === 'suspended') {
                    const resumeAudio = function() {
                        audioContext.resume();
                        document.removeEventListener('click', resumeAudio);
                    };
                    document.addEventListener('click', resumeAudio);
                }
                
                // Load gunshot sound with better error handling
                console.log('Loading gunshot sound...');
                
                // Try to load local file first
                fetch('./Gunshots.mp3')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Could not load local gunshot sound`);
                        }
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        console.log('Local gunshot sound loaded successfully');
                        gunShotSound = audioBuffer;
                    })
                    .catch(error => {
                        console.error('Error loading local gunshot sound, trying fallback:', error);
                        // Try online fallback
                        fetch('https://freesound.org/data/previews/333/333387_5244537-lq.mp3')
                            .then(response => response.arrayBuffer())
                            .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                            .then(audioBuffer => {
                                console.log('Fallback gunshot sound loaded successfully');
                                gunShotSound = audioBuffer;
                            })
                            .catch(fallbackError => {
                                console.error('Error loading fallback gunshot sound:', fallbackError);
                                // HTML5 Audio fallback
                                createFallbackGunSound();
                            });
                    });
                
                // Load footstep sound with better error handling
                console.log('Loading footstep sound...');
                
                // Try to load local file first
                fetch('./Footsteps.mp3')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Could not load local footstep sound`);
                        }
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        console.log('Local footstep sound loaded successfully');
                        footstepSound = audioBuffer;
                    })
                    .catch(error => {
                        console.error('Error loading local footstep sound, trying fallback:', error);
                        // Try online fallback
                        fetch('https://freesound.org/data/previews/348/348665_5257179-lq.mp3')
                            .then(response => response.arrayBuffer())
                            .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                            .then(audioBuffer => {
                                console.log('Fallback footstep sound loaded successfully');
                                footstepSound = audioBuffer;
                            })
                            .catch(fallbackError => {
                                console.error('Error loading fallback footstep sound:', fallbackError);
                                // HTML5 Audio fallback
                                createFallbackFootstepSound();
                            });
                    });
                    
                // Load grenade sound
                console.log('Loading grenade sound...');
                fetch('./Grenade.mp3') // Assuming Grenade.mp3 is in the same folder
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Could not load local grenade sound`);
                        }
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        console.log('Grenade sound loaded successfully');
                        grenadeSound = audioBuffer;
                    })
                    .catch(error => {
                        console.error('Error loading grenade sound:', error);
                        // Optionally create a fallback HTML5 audio element here if needed
                    });
                    
            } catch (e) {
                console.error('Web Audio API not supported in this browser:', e);
                // Use fallbacks
                createFallbackGunSound();
                createFallbackFootstepSound();
            }
        }
        
        // Create fallback sounds using HTML5 Audio
        function createFallbackGunSound() {
            console.log('Creating fallback gunshot sound using HTML5 Audio');
            try {
                // Try local file first
                gunShotSound = new Audio('./Gunshots.mp3');
                gunShotSound.addEventListener('error', () => {
                    console.log('Local gunshot sound failed, using online fallback');
                    gunShotSound = new Audio('https://freesound.org/data/previews/333/333387_5244537-lq.mp3');
                    gunShotSound.load();
                });
                gunShotSound.load();
            } catch (e) {
                // Use online fallback
                gunShotSound = new Audio('https://freesound.org/data/previews/333/333387_5244537-lq.mp3');
                gunShotSound.load();
            }
            
            // Add event listeners to track loading status
            gunShotSound.addEventListener('canplaythrough', () => {
                console.log('Gunshot sound loaded successfully');
            });
        }
        
        function createFallbackFootstepSound() {
            console.log('Creating fallback footstep sound using HTML5 Audio');
            try {
                // Try local file first
                footstepSound = new Audio('./Footsteps.mp3');
                footstepSound.addEventListener('error', () => {
                    console.log('Local footstep sound failed, using online fallback');
                    footstepSound = new Audio('https://freesound.org/data/previews/348/348665_5257179-lq.mp3');
                    footstepSound.load();
                });
                footstepSound.load();
            } catch (e) {
                // Use online fallback
                footstepSound = new Audio('https://freesound.org/data/previews/348/348665_5257179-lq.mp3');
                footstepSound.load();
            }
            
            // Add event listeners to track loading status
            footstepSound.addEventListener('canplaythrough', () => {
                console.log('Footstep sound loaded successfully');
            });
        }
        
        // Play gunshot sound
        function playGunshot() {
            if (!gunShotSound) {
                console.warn('Gunshot sound not loaded yet');
                return;
            }
            
            try {
                if (audioContext) {
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    
                    if (typeof gunShotSound !== 'object' || gunShotSound instanceof AudioBuffer) {
                        // Web Audio API method
                        const source = audioContext.createBufferSource();
                        source.buffer = gunShotSound;
                        source.connect(audioContext.destination);
                        source.start(0);
                        console.log('Playing gunshot with Web Audio API');
                    } else if (gunShotSound instanceof Audio) {
                        // HTML5 Audio fallback
                        gunShotSound.currentTime = 0;
                        gunShotSound.volume = 1.0;
                        const playPromise = gunShotSound.play();
                        
                        if (playPromise !== undefined) {
                            playPromise.catch(e => {
                                console.error('Error playing gunshot:', e);
                                // Try again with user interaction
                                const retryPlay = function() {
                                    gunShotSound.play();
                                    document.removeEventListener('click', retryPlay);
                                };
                                document.addEventListener('click', retryPlay, { once: true });
                            });
                        }
                        console.log('Playing gunshot with HTML5 Audio');
                    }
                } else if (gunShotSound instanceof Audio) {
                    // Direct HTML5 Audio when no context
                    gunShotSound.currentTime = 0;
                    gunShotSound.volume = 1.0;
                    gunShotSound.play().catch(e => console.error('Error playing gunshot:', e));
                    console.log('Playing gunshot with direct HTML5 Audio');
                }
            } catch (error) {
                console.error('Error in playGunshot:', error);
            }
        }
        
        // Play footstep sound
        function playFootstep() {
            if (!footstepSound) {
                console.warn('Footstep sound not loaded yet');
                return;
            }
            
            const currentTime = performance.now();
            
            try {
                if (audioContext) {
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    
                    if (typeof footstepSound !== 'object' || footstepSound instanceof AudioBuffer) {
                        // Web Audio API method
                        const source = audioContext.createBufferSource();
                        source.buffer = footstepSound;
                        // Set playback rate based on running state
                        source.playbackRate.value = isRunning ? 1.4 : 1.0;
                        // Lower volume for footsteps
                        const gainNode = audioContext.createGain();
                        gainNode.gain.value = 0.3;
                        source.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        source.start(0);
                        console.log('Playing footstep with Web Audio API');
                    } else if (footstepSound instanceof Audio) {
                        // HTML5 Audio fallback
                        footstepSound.currentTime = 0;
                        footstepSound.volume = 0.3;
                        // Set playback rate based on running state
                        footstepSound.playbackRate = isRunning ? 1.4 : 1.0;
                        const playPromise = footstepSound.play();
                        
                        if (playPromise !== undefined) {
                            playPromise.catch(e => {
                                console.error('Error playing footstep:', e);
                            });
                        }
                        console.log('Playing footstep with HTML5 Audio');
                    }
                } else if (footstepSound instanceof Audio) {
                    // Direct HTML5 Audio when no context
                    footstepSound.currentTime = 0;
                    footstepSound.volume = 0.3;
                    // Set playback rate based on running state
                    footstepSound.playbackRate = isRunning ? 1.4 : 1.0;
                    footstepSound.play().catch(e => console.error('Error playing footstep:', e));
                    console.log('Playing footstep with direct HTML5 Audio');
                }
            } catch (error) {
                console.error('Error in playFootstep:', error);
            }
        }
        
        // Create environmental objects
        function createEnvironment() {
            // Add trees
            const treeGeometry = new THREE.CylinderGeometry(0, 1.5, 5, 4);
            const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x2d4c1e });
            
            for (let i = 0; i < 50; i++) {
                const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                tree.position.x = Math.random() * 200 - 100;
                tree.position.z = Math.random() * 200 - 100;
                
                // Don't place trees too close to the player
                if (tree.position.length() < 10) continue;
                
                scene.add(tree);
            }
            
            // Add rocks
            // Create custom rock geometry that mimics the image (faceted with flat bottom)
            function createCustomRockGeometry() {
                const geometry = new THREE.BufferGeometry();
                
                // Vertices for a rock with flat bottom and angled facets
                const vertices = new Float32Array([
                    // Bottom face (flat)
                    -1.0, 0.0, -1.0,
                    1.0, 0.0, -1.0,
                    1.0, 0.0, 1.0,
                    -1.0, 0.0, 1.0,
                    
                    // Top vertex
                    0.0, 1.5, 0.0,
                    
                    // Mid-height vertices for facets
                    -0.7, 0.8, -0.7,
                    0.7, 0.8, -0.7,
                    0.7, 0.8, 0.7,
                    -0.7, 0.8, 0.7,
                    
                    // Additional vertices for more complex shape
                    -0.4, 1.2, 0.0,
                    0.4, 1.2, 0.0,
                    0.0, 1.2, -0.4,
                    0.0, 1.2, 0.4
                ]);
                
                // Faces (triangles)
                const indices = [
                    // Bottom face
                    0, 1, 2,
                    0, 2, 3,
                    
                    // Side facets - lower section
                    0, 5, 1,
                    1, 6, 2,
                    2, 7, 3,
                    3, 8, 0,
                    
                    // Side facets connecting to mid-height
                    5, 6, 1,
                    6, 7, 2,
                    7, 8, 3,
                    8, 5, 0,
                    
                    // Upper facets
                    5, 9, 6,
                    6, 10, 7,
                    7, 11, 8,
                    8, 12, 5,
                    
                    // Top facets
                    9, 4, 10,
                    10, 4, 11,
                    11, 4, 12,
                    12, 4, 9
                ];
                
                geometry.setIndex(indices);
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                geometry.computeVertexNormals();
                
                return geometry;
            }
            
            const rockMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xaaaaaa, 
                roughness: 0.8,
                metalness: 0.2
            });
            
            for (let i = 0; i < 50; i++) {
                const rockGeometry = createCustomRockGeometry();
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                
                rock.position.x = Math.random() * 200 - 100;
                rock.position.z = Math.random() * 200 - 100;
                
                // Random scale but maintain proportions better for this particular shape
                const scale = Math.random() * 1 + 0.5;
                rock.scale.set(scale, scale * 0.8, scale);
                
                // Random rotation but only around Y axis to keep the flat bottom down
                rock.rotation.y = Math.random() * Math.PI * 2;
                
                // Don't place rocks too close to the player
                if (rock.position.length() < 10) continue;
                
                scene.add(rock);
            }
        }
        
        // Spawn a zombie at a random position
        function spawnZombie(isToughZombie = false) {
            let zombieBody = new THREE.Group();
            
            // Create voxel-style zombie with missing blocks effect
            function createVoxelizedZombie(isToughZombie) {
                const voxelGroup = new THREE.Group();
                const voxelSize = isToughZombie ? 0.15 : 0.1; // Larger voxels for tough zombies
                const scale = isToughZombie ? 1.5 : 1.0; // Overall scale for tough zombies
                
                // Define base colors
                const bodyColor = isToughZombie ? 0x1a472a : 0x2a623d; // Dark green
                const clothingColor = isToughZombie ? 0x5a3a28 : 0x704214; // Brown clothing
                const eyeColor = isToughZombie ? 0x00ff00 : 0x39ff14; // Bright green eyes
                
                // Create head - cube with missing blocks
                const headSize = 0.5 * scale; // Overall head size
                const headVoxelCount = Math.floor(headSize / voxelSize);
                const headGroup = new THREE.Group();
                
                for (let x = 0; x < headVoxelCount; x++) {
                    for (let y = 0; y < headVoxelCount; y++) {
                        for (let z = 0; z < headVoxelCount; z++) {
                            // Skip some voxels randomly to create deteriorated look
                            // More deterioration for tough zombies
                            const deteriorationChance = isToughZombie ? 0.25 : 0.15;
                            if (Math.random() < deteriorationChance) continue;
                            
                            // Don't remove voxels near eyes
                            const isEyeRegion = (z === headVoxelCount-1 && 
                                               ((x === Math.floor(headVoxelCount * 0.3) && y === Math.floor(headVoxelCount * 0.6)) || 
                                                (x === Math.floor(headVoxelCount * 0.7) && y === Math.floor(headVoxelCount * 0.6))));
                            
                            if (isEyeRegion) continue; // Skip here because we'll add eyes separately
                            
                            const voxel = new THREE.Mesh(
                                new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize),
                                new THREE.MeshStandardMaterial({ 
                                    color: bodyColor,
                                    roughness: 0.7,
                                    metalness: 0.2
                                })
                            );
                            
                            voxel.position.set(
                                (x - headVoxelCount/2) * voxelSize,
                                (y - headVoxelCount/2) * voxelSize,
                                (z - headVoxelCount/2) * voxelSize
                            );
                            
                            headGroup.add(voxel);
                        }
                    }
                }
                
                // Add glowing eyes - larger for tough zombies
                const eyeSize = isToughZombie ? voxelSize * 2.0 : voxelSize * 1.2;
                const leftEye = new THREE.Mesh(
                    new THREE.BoxGeometry(eyeSize, eyeSize, eyeSize * 0.6),
                    new THREE.MeshBasicMaterial({ 
                        color: eyeColor,
                        emissive: eyeColor,
                        emissiveIntensity: isToughZombie ? 1.5 : 1.0
                    })
                );
                
                const rightEye = leftEye.clone();
                
                leftEye.position.set(-headSize * 0.3, headSize * 0.1, headSize * 0.5);
                rightEye.position.set(headSize * 0.3, headSize * 0.1, headSize * 0.5);
                
                headGroup.add(leftEye);
                headGroup.add(rightEye);
                headGroup.position.y = 1.7 * scale; // Position head on top of body
                voxelGroup.add(headGroup);
                
                // Create body - torso with missing blocks
                const torsoWidth = 0.6 * scale;
                const torsoHeight = 0.8 * scale;
                const torsoDepth = isToughZombie ? 0.5 * scale : 0.3 * scale; // Fatter for tough zombies
                const torsoGroup = new THREE.Group();
                
                const torsoWCount = Math.floor(torsoWidth / voxelSize);
                const torsoHCount = Math.floor(torsoHeight / voxelSize);
                const torsoDCount = Math.floor(torsoDepth / voxelSize);
                
                for (let x = 0; x < torsoWCount; x++) {
                    for (let y = 0; y < torsoHCount; y++) {
                        for (let z = 0; z < torsoDCount; z++) {
                            // Skip some voxels randomly for deterioration effect
                            if (Math.random() < 0.2) continue;
                            
                            // Determine if this is a jacket part (upper body) or pants (lower body)
                            const isJacket = y > torsoHCount * 0.5;
                            
                            const voxel = new THREE.Mesh(
                                new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize),
                                new THREE.MeshStandardMaterial({ 
                                    color: isJacket ? clothingColor : 0x1a1a2e, // Jacket or pants
                                    roughness: 0.8,
                                    metalness: 0.1
                                })
                            );
                            
                            voxel.position.set(
                                (x - torsoWCount/2) * voxelSize,
                                (y - torsoHCount/2) * voxelSize,
                                (z - torsoDCount/2) * voxelSize
                            );
                            
                            torsoGroup.add(voxel);
                        }
                    }
                }
                
                // Add green core element visible through missing blocks - larger for tough zombies
                const coreSize = Math.min(torsoWidth, torsoHeight, torsoDepth) * (isToughZombie ? 0.5 : 0.4);
                const core = new THREE.Mesh(
                    new THREE.BoxGeometry(coreSize, coreSize, coreSize),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x39ff14,
                        emissive: 0x39ff14,
                        emissiveIntensity: isToughZombie ? 1.2 : 0.7
                    })
                );
                core.position.set(0, 0, 0);
                torsoGroup.add(core);
                
                torsoGroup.position.y = 1.1 * scale; // Position torso
                voxelGroup.add(torsoGroup);
                
                // Create arms - thicker for tough zombies
                const armLength = 0.7 * scale;
                const armWidth = isToughZombie ? 0.25 * scale : 0.15 * scale;
                
                for (let side = -1; side <= 1; side += 2) {
                    if (side === 0) continue;
                    
                    const armGroup = new THREE.Group();
                    const armWCount = Math.floor(armWidth / voxelSize);
                    const armLCount = Math.floor(armLength / voxelSize);
                    
                    for (let x = 0; x < armWCount; x++) {
                        for (let y = 0; y < armLCount; y++) {
                            for (let z = 0; z < armWCount; z++) {
                                // Skip some voxels
                                if (Math.random() < 0.3) continue;
                                
                                // Is it a hand or sleeve?
                                const isHand = y < armLCount * 0.3;
                                
                                const voxel = new THREE.Mesh(
                                    new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize),
                                    new THREE.MeshStandardMaterial({ 
                                        color: isHand ? bodyColor : clothingColor,
                                        roughness: 0.8,
                                        metalness: 0.1
                                    })
                                );
                                
                                voxel.position.set(
                                    (x - armWCount/2) * voxelSize,
                                    (y - armLCount/2) * voxelSize,
                                    (z - armWCount/2) * voxelSize
                                );
                                
                                armGroup.add(voxel);
                            }
                        }
                    }
                    
                    // Position and rotate arm
                    armGroup.position.set(side * (torsoWidth/2 + armWidth/2), 1.1 * scale, 0);
                    armGroup.rotation.z = side * Math.PI / 6; // Slight outward angle
                    voxelGroup.add(armGroup);
                }
                
                // Create legs - thicker for tough zombies
                const legLength = 0.8 * scale;
                const legWidth = isToughZombie ? 0.25 * scale : 0.15 * scale;
                
                for (let side = -1; side <= 1; side += 2) {
                    if (side === 0) continue;
                    
                    const legGroup = new THREE.Group();
                    const legWCount = Math.floor(legWidth / voxelSize);
                    const legLCount = Math.floor(legLength / voxelSize);
                    
                    for (let x = 0; x < legWCount; x++) {
                        for (let y = 0; y < legLCount; y++) {
                            for (let z = 0; z < legWCount; z++) {
                                // Skip some voxels
                                if (Math.random() < 0.25) continue;
                                
                                const voxel = new THREE.Mesh(
                                    new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize),
                                    new THREE.MeshStandardMaterial({ 
                                        color: 0x1a1a2e, // Dark pants
                                        roughness: 0.8,
                                        metalness: 0.1
                                    })
                                );
                                
                                voxel.position.set(
                                    (x - legWCount/2) * voxelSize,
                                    (y - legLCount/2) * voxelSize,
                                    (z - legWCount/2) * voxelSize
                                );
                                
                                legGroup.add(voxel);
                            }
                        }
                    }
                    
                    // Position leg
                    legGroup.position.set(side * legWidth * 1.5, legLength * 0.6, 0);
                    voxelGroup.add(legGroup);
                }
                
                return voxelGroup;
            }
            
            // Create the zombie based on type
            const zombie = createVoxelizedZombie(isToughZombie);
            zombieBody.add(zombie);
            
            // Position zombie at a random location around the player
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 20 + 30; // Between 30 and 50 units away
            
            zombieBody.position.x = Math.cos(angle) * distance;
            zombieBody.position.z = Math.sin(angle) * distance;
            
            // Add properties for game logic
            if (isToughZombie) {
                zombieBody.userData.health = 350; // 14 hits at 25 damage
                zombieBody.userData.speed = Math.random() * 0.01 + 0.005; // Slower speed
                zombieBody.userData.isToughZombie = true;
            } else {
                zombieBody.userData.health = 200; // 8 hits at 25 damage
                zombieBody.userData.speed = Math.random() * 0.02 + 0.01;
            }
            
            zombieBody.userData.isZombie = true;
            zombieBody.userData.hitsTaken = 0; // Track how many hits this zombie has taken
            zombieBody.userData.animationPhase = Math.random() * Math.PI * 2; // For walking animation
            zombieBody.name = "zombie"; // Add a name for easier identification
            
            // Make sure all child objects reference back to the parent zombie
            zombieBody.traverse(child => {
                child.userData.zombieRoot = zombieBody;
            });
            
            // Debug zombie creation
            console.log(`Created ${isToughZombie ? 'Tough' : 'Normal'} zombie with ${zombieBody.userData.health} health`);
            
            scene.add(zombieBody);
            zombies.push(zombieBody);
        }
        
        // Handle mouse movement
        function onMouseMove(event) {
            if (document.pointerLockElement === document.body) {
                camera.rotation.y -= event.movementX * 0.0008; // Reduced from 0.002
                camera.rotation.x -= event.movementY * 0.0008; // Reduced from 0.002
                
                // Even more restricted vertical look (reduced from PI/3 to PI/4 to minimize tilt)
                camera.rotation.x = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, camera.rotation.x));
            }
        }
        
        // Handle key down events
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW':
                    moveBackward = true;
                    break;
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'KeyS':
                    moveForward = true;
                    break;
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isRunning = true;
                    break;
                case 'KeyQ':
                    if (currentWeapon === 'sniper') {
                        console.log("Q pressed with sniper equipped");
                        toggleScope();
                    }
                    break;
                case 'Digit1':
                    switchWeapon('pistol');
                    break;
                case 'Digit2':
                    switchWeapon('shotgun');
                    break;
                case 'Digit3':
                    switchWeapon('sniper');
                    break;
                case 'Digit4': // Machine gun key
                    switchWeapon('machineGun');
                    break;
                case 'Digit5': // Grenade key
                    throwGrenade();
                    break;
                case 'Space':
                // Only jump if not already jumping
                    if (!isJumping) {
                        isJumping = true;
                        jumpVelocity = 5; // Initial jump velocity
                    }
                    break;
            }
        }
        
        // Handle key up events
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                    moveBackward = false;
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyS':
                    moveForward = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isRunning = false;
                    break;
            }
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Shoot function
        function shoot() {
            if (isGameOver || document.pointerLockElement !== document.body) return;
            
            const currentTime = performance.now() / 1000; // Current time in seconds
            const weapon = weapons[currentWeapon];
            
            // Check fire rate
            if (currentTime - weapon.lastFired < weapon.fireRate) {
                return; // Too soon to fire again
            }
            
            // Check ammo for non-infinite weapons
            if (!weapon.infiniteAmmo) {
                if (currentWeapon === 'shotgun') {
                    if (shotgunAmmo <= 0) {
                        showWeaponMessage("Out of shotgun ammo!");
                        return;
                    }
                    shotgunAmmo--;
                } else if (currentWeapon === 'sniper') {
                    if (sniperAmmo <= 0) {
                        showWeaponMessage("Out of sniper ammo!");
                        return;
                    }
                    sniperAmmo--;
                } else if (currentWeapon === 'machineGun') {
                    if (machineGunAmmo <= 0) {
                        showWeaponMessage("Out of machine gun ammo!");
                        return;
                    }
                    machineGunAmmo--;
                }
                
                // Update ammo display
                updateAmmoDisplay();
            }
            
            // Update last fired time
            weapon.lastFired = currentTime;
            
            // Play gunshot sound
            if (audioContext && gunShotSound) {
                playGunShotSound();
            }
            
            // Create muzzle flash with weapon-specific properties
            createMuzzleFlash(weapon.muzzleFlashSize, weapon.muzzleFlashColor);
            
            // For shotgun, create multiple bullets with spread
            if (currentWeapon === 'shotgun') {
                for (let i = 0; i < weapon.pellets; i++) {
                    createBullet(weapon, true);
                }
            } else if (currentWeapon === 'machineGun') {
                // Create a single bullet with slight spread for machine gun
                createBullet(weapon, true);
            } else {
                // For pistol and sniper, create single bullet
                createBullet(weapon);
            }
            
            // Handle hit detection based on weapon
            if (currentWeapon === 'sniper') {
                // Sniper has better range and more precise aiming
                detectHits(weapon.damage, weapon.range, 0.01);
            } else if (currentWeapon === 'shotgun') {
                // Shotgun has shorter range but can hit multiple enemies
                detectHits(weapon.damage, weapon.range, 0.2, true);
            } else if (currentWeapon === 'machineGun') {
                // Machine gun has good range and damage with slight spread
                detectHits(weapon.damage, weapon.range, 0.1, true);
            } else {
                // Pistol is standard
                detectHits(weapon.damage, weapon.range, 0.05);
            }
        }
        
        // Function to create a bullet with weapon properties
        function createBullet(weapon, isSpread = false) {
            // Limit maximum active bullets to prevent lag
            if (bullets.length > 100) {
                // Remove oldest bullet if we're over the limit
                const oldBullet = bullets.shift();
                scene.remove(oldBullet);
            }
            
            // Use shared geometries and materials to improve performance
            const bulletGeometry = new THREE.SphereGeometry(weapon.bulletSize, 4, 4); // Reduced geometry complexity
            const bulletMaterial = new THREE.MeshBasicMaterial({color: 0xffff00});
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // Position bullet at camera position
            bullet.position.copy(camera.position);
            
            // Set bullet direction based on camera direction with optional spread
            const bulletDirection = new THREE.Vector3(0, 0, -1);
            bulletDirection.applyQuaternion(camera.quaternion);
            
            // Add spread if needed (for shotgun or machine gun)
            if (isSpread) {
                const spread = weapon.spread;
                bulletDirection.x += (Math.random() - 0.5) * spread;
                bulletDirection.y += (Math.random() - 0.5) * spread;
                bulletDirection.z += (Math.random() - 0.5) * spread;
                bulletDirection.normalize();
            }
            
            bullet.userData.velocity = bulletDirection.multiplyScalar(weapon.bulletSpeed);
            bullet.userData.lifespan = weapon.bulletLifespan;
            bullet.userData.weapon = currentWeapon;
            
            scene.add(bullet);
            bullets.push(bullet);
        }
        
        // Updated muzzle flash function to accept parameters
        function createMuzzleFlash(size = 100, color = 'rgba(255,255,0,0.8)') {
            // Create a div for the muzzle flash
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.top = '50%';
            flash.style.left = '50%';
            flash.style.width = `${size}px`;
            flash.style.height = `${size}px`;
            flash.style.marginLeft = `-${size/2}px`;
            flash.style.marginTop = `-${size/2}px`;
            flash.style.backgroundImage = `radial-gradient(circle, ${color} 0%, rgba(255,165,0,0.4) 40%, rgba(255,69,0,0) 70%)`;
            flash.style.pointerEvents = 'none';
            flash.style.zIndex = '999';
            flash.style.opacity = '0.7';
            document.body.appendChild(flash);
            
            // Remove the flash after a short delay
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
            }, 100);
        }
        
        // Function to detect hits with weapon-specific properties
        function detectHits(damage, range, precision, canHitMultiple = false) {
            // Use raycaster for hit detection
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            // Get all potential hits
            const allHits = raycaster.intersectObjects(zombies);
            
            // If no direct hits on zombie objects, check for hits on parts
            if (allHits.length === 0) {
                // Gather all zombie child objects
                const zombieParts = [];
                zombies.forEach(zombie => {
                    zombie.traverse(child => {
                        if (child.isMesh) {
                            // Store reference to parent zombie or robot
                            child.userData.zombieRoot = zombie;
                            zombieParts.push(child);
                        }
                    });
                });
                
                // Check for hits on any zombie/robot part
                const partHits = raycaster.intersectObjects(zombieParts);
                
                // Process hits
                if (partHits.length > 0) {
                    processHits(partHits, damage, range, canHitMultiple);
                }
            } else {
                // Process direct hits
                processHits(allHits, damage, range, canHitMultiple);
            }
        }
        
        // Process hits based on weapon properties
        function processHits(hits, damage, range, canHitMultiple) {
            const processedTargets = new Set();
            
            for (const hit of hits) {
                if (hit.distance > range) continue;
                const hitObject = hit.object.userData.zombieRoot || hit.object;
                if (processedTargets.has(hitObject) && !canHitMultiple) continue;
                processedTargets.add(hitObject);
                
                // Apply damage
                if (hitObject.userData.isRobot) {
                    hitObject.userData.hitsTaken = (hitObject.userData.hitsTaken || 0) + 1;
                    hitObject.userData.health = hitObject.userData.maxHealth - hitObject.userData.hitsTaken;
                    console.log(`Robot hit! Hits taken: ${hitObject.userData.hitsTaken}/4, Health remaining: ${hitObject.userData.health}`);
                } else {
                    hitObject.userData.health -= damage;
                    hitObject.userData.hitsTaken = (hitObject.userData.hitsTaken || 0) + 1;
                    console.log(`Zombie hit! Type: ${hitObject.userData.isToughZombie ? 'Tough' : 'Normal'}, Health: ${hitObject.userData.health}, Hits taken: ${hitObject.userData.hitsTaken}`);
                }
                
                addHitFlashEffect(hitObject);
                
                // Check if object is destroyed
                if (hitObject.userData.health <= 0) {
                    let enemyRemoved = false; // Flag to track if enemy was removed
                    if (hitObject.userData.isRobot) {
                        console.log("Robot destroyed after exactly 4 hits!");
                        scene.remove(hitObject);
                        robots = robots.filter(r => r !== hitObject);
                        zombies = zombies.filter(z => z !== hitObject);
                        enemyRemoved = true;
                    } else if (hitObject.userData.isBoss) {
                        console.log("BOSS DEFEATED!!!");
                        
                        // Use the global helper function to show the overlay
                        showRoundTransitionOverlay();
                        
                        scene.remove(hitObject);
                        zombies = zombies.filter(z => z !== hitObject);
                        bossZombie = null;
                        enemyRemoved = true; // Keep this true for score and potential powerup drop
                    } else {
                        // Regular zombies and crawlers
                        console.log("Zombie killed!");
                    scene.remove(hitObject);
                    zombies = zombies.filter(z => z !== hitObject);
                        enemyRemoved = true;
                    }
                    
                    if (enemyRemoved) {
                    // Update score
                        let scorePoints = 100;
                        if (hitObject.userData.isToughZombie) scorePoints = 500;
                        else if (hitObject.userData.isRobot) scorePoints = 250;
                        else if (hitObject.userData.isCrawler) scorePoints = 200;
                        else if (hitObject.userData.isBoss) scorePoints = 1000;
                    score += scorePoints;
                    document.getElementById('score').textContent = `Score: ${score}`;
                    
                        // Power-up Drop
                        const enemyPosition = hitObject.position.clone();
                    if (Math.random() < 0.50) {
                        const powerupTypes = ['shotgun', 'sniper', 'grenade'];
                        const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                        spawnPowerup(randomType, enemyPosition);
                        console.log(`Spawning ${randomType} power-up from enemy kill`);
                    }
                    
                        // Spawn new enemy
                        if (!hitObject.userData.isBoss) { // Only spawn new enemies if it wasn't the boss
                    setTimeout(() => {
                                // Respawn logic based on currentWave
                        if (currentWave === 3) {
                            const rand = Math.random();
                                    if (rand < 0.3) spawnRobot();
                                    else if (rand < 0.6) spawnZombie(true); // Tough zombie in wave 3
                                    else spawnZombie(false);
                        } else if (currentWave === 2) {
                            const spawnToughZombie = Math.random() < 0.4;
                                    spawnZombie(spawnToughZombie); // Tough zombie in wave 2 (random chance)
                                } else if (currentWave === 1) {
                                    // *** Changed this line: Only spawn regular zombies in wave 1 ***
                            spawnZombie(false);
                        }
                    }, Math.random() * 2000 + 1000);
                        }
                    }
                    
                    // Stop processing further hits on this shot if the weapon can't hit multiple targets
                    if (!canHitMultiple) break;
                }
                
                // Reduce damage for subsequent pellets in shotgun blast
                if (canHitMultiple && currentWeapon === 'shotgun') {
                    damage = Math.max(10, damage - 5);
                }
            }
        }
        
        // Add hit flash effect function
        function addHitFlashEffect(zombie) {
            // Find the actual mesh children to apply the effect to
            const applyFlashToObject = (obj) => {
                // Store original materials
                if (!obj.userData.flashApplied) {
                    obj.userData.flashApplied = true;
                    obj.userData.originalMaterials = [];
                    
                    // Find all mesh children
                    obj.traverse(child => {
                        if (child.isMesh && child.material) {
                            obj.userData.originalMaterials.push({
                                mesh: child,
                                material: child.material.clone()
                            });
                            
                            // Create flash material
                            child.userData.flashMaterial = new THREE.MeshBasicMaterial({
                                color: 0xff0000,
                                emissive: 0xff0000,
                                emissiveIntensity: 1
                            });
                            
                            // Apply flash material immediately
                            child.material = child.userData.flashMaterial;
                        }
                    });
                } else {
                    // Just reapply the flash materials
                    obj.traverse(child => {
                        if (child.isMesh && child.userData.flashMaterial) {
                            child.material = child.userData.flashMaterial;
                        }
                    });
                }
            };
            
            // Apply flash effect
            applyFlashToObject(zombie);
            
            // Restore original materials after a short delay
            setTimeout(() => {
                if (zombie.userData.originalMaterials) {
                    zombie.userData.originalMaterials.forEach(item => {
                        if (item.mesh) {
                            item.mesh.material = item.material;
                        }
                    });
                }
            }, 100);
        }
        
        // Update zombie health bar
        function updateZombieHealthBar(zombie) {
            if (zombie.userData.healthBar) {
                // Calculate health percentage
                const healthPercent = zombie.userData.health / zombie.userData.initialHealth;
                
                // Update health bar scale
                zombie.userData.healthBar.scale.x = Math.max(0, healthPercent);
                
                // Position health bar to align left
                zombie.userData.healthBar.position.x = (1 - healthPercent) * 0.6;
                
                // Make health bar container always face camera
                zombie.userData.healthBarContainer.lookAt(camera.position);
            }
        }
        
        // Add floating hit counter
        function addFloatingHitCounter(zombie, damage) {
            // Create HTML element for the hit counter
            const hitCounter = document.createElement('div');
            hitCounter.textContent = `-${damage}`;
            hitCounter.style.position = 'absolute';
            hitCounter.style.color = 'red';
            hitCounter.style.fontSize = '24px';
            hitCounter.style.fontWeight = 'bold';
            hitCounter.style.textShadow = '0 0 3px black';
            hitCounter.style.userSelect = 'none';
            hitCounter.style.pointerEvents = 'none';
            hitCounter.style.zIndex = '1000';
            document.body.appendChild(hitCounter);
            
            // Get screen position for the zombie
            const zombiePos = new THREE.Vector3();
            zombie.getWorldPosition(zombiePos);
            
            // Project the 3D position to screen coordinates
            const screenPos = zombiePos.project(camera);
            
            // Convert to pixel coordinates
            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-(screenPos.y * 0.5) + 0.5) * window.innerHeight;
            
            // Position the hit counter
            hitCounter.style.left = `${x}px`;
            hitCounter.style.top = `${y}px`;
            
            // Animation variables
            let opacity = 1;
            let yOffset = 0;
            const fadeSpeed = 0.05;
            const riseSpeed = 1;
            
            // Animate the hit counter
            const animate = () => {
                // Move upward
                yOffset -= riseSpeed;
                hitCounter.style.top = `${y + yOffset}px`;
                
                // Fade out
                opacity -= fadeSpeed;
                hitCounter.style.opacity = opacity;
                
                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    // Remove from DOM when animation is complete
                    document.body.removeChild(hitCounter);
                }
            };
            
            // Start animation
            requestAnimationFrame(animate);
        }
        
        // Add new function to start game
        function startGame() {
            console.log('startGame function called');
            
            // Hide start UI
            const welcomeScreen = document.getElementById('welcomeScreen');
            console.log('welcomeScreen element:', welcomeScreen);
            
            if (welcomeScreen) {
                welcomeScreen.style.display = 'none';
                console.log('welcomeScreen hidden');
            } else {
                console.error('welcomeScreen element not found!');
            }

            // Show blur overlay and Round 1 text
            const blurOverlay = document.getElementById('blurOverlay');
            const roundStartText = document.getElementById('roundStartText');
            if (blurOverlay && roundStartText) {
                blurOverlay.style.display = 'block';
                roundStartText.style.display = 'block';
                console.log('Round 1 splash screen shown');
            } else {
                console.error('Blur overlay or Round 1 text element not found!');
            }

            // Wait 5 seconds, then start the game
            setTimeout(() => {
                console.log('5 second delay finished, starting game');
                // Hide overlay and text
                if (blurOverlay && roundStartText) {
                    blurOverlay.style.display = 'none';
                    roundStartText.style.display = 'none';
                }

                // Lock pointer
                try {
                    document.body.requestPointerLock();
                    console.log('Pointer lock requested');
                } catch (error) {
                    console.error('Error requesting pointer lock:', error);
                }
                
                // Spawn initial zombies
                for (let i = 0; i < 5; i++) {
                    spawnZombie(false); // Only spawn small zombies in wave 1
                }
                console.log('Initial zombies spawned');

                // Start the game loop if not already started
                if (!gameStarted) {
                    gameStarted = true;
                    console.log('Starting animation loop');
                    animate();
                }
            }, 5000); // 5000 milliseconds = 5 seconds
        }
        
        // Update minimap function
        function updateMinimap() {
            // Clear canvas
            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            // Define constants for minimap
            const radarRadius = minimapCanvas.width/2 - 4;
            const centerX = minimapCanvas.width/2;
            const centerY = minimapCanvas.height/2;
            
            // Draw circular background
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            minimapCtx.beginPath();
            minimapCtx.arc(centerX, centerY, radarRadius + 2, 0, Math.PI * 2);
            minimapCtx.fill();
            
            // Draw concentric radar circles (static)
            minimapCtx.strokeStyle = 'rgba(200, 200, 200, 0.2)';
            minimapCtx.lineWidth = 1;
            
            // Draw outer and inner radar circles
            [radarRadius * 0.5, radarRadius].forEach(radius => {
                minimapCtx.beginPath();
                minimapCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                minimapCtx.stroke();
            });
            
            // Draw compass directions (static)
            minimapCtx.textAlign = 'center';
            minimapCtx.textBaseline = 'middle';
            minimapCtx.fillStyle = 'rgba(200, 200, 200, 0.5)';
            minimapCtx.font = '10px Arial';
            
            const directions = [
                { label: 'N', x: centerX, y: centerY - radarRadius + 8 },
                { label: 'E', x: centerX + radarRadius - 8, y: centerY },
                { label: 'S', x: centerX, y: centerY + radarRadius - 8 },
                { label: 'W', x: centerX - radarRadius + 8, y: centerY }
            ];
            
            directions.forEach(dir => {
                minimapCtx.fillText(dir.label, dir.x, dir.y);
            });
            
            // Draw player position (center)
            minimapCtx.fillStyle = 'blue';
            minimapCtx.beginPath();
            minimapCtx.arc(centerX, centerY, 3, 0, Math.PI * 2);
            minimapCtx.fill();
            
            // Draw campfire as green dot
            const relativeCampfireX = healingStation.position.x - camera.position.x;
            const relativeCampfireZ = healingStation.position.z - camera.position.z;
            
            // Scale position to fit minimap (1 unit = 5 pixels)
            const campfireMapX = (relativeCampfireX * 5) + centerX;
            const campfireMapY = (relativeCampfireZ * 5) + centerY;
            
            // Check if campfire is within minimap radius
            const campfireDistance = Math.sqrt(
                Math.pow(campfireMapX - centerX, 2) + 
                Math.pow(campfireMapY - centerY, 2)
            );
            
            if (campfireDistance < radarRadius) {
                // Draw campfire dot
                minimapCtx.fillStyle = '#00ff00'; // Bright green
                minimapCtx.beginPath();
                minimapCtx.arc(campfireMapX, campfireMapY, 4, 0, Math.PI * 2);
                minimapCtx.fill();
            }
            
            // Draw zombies and enemies
            zombies.forEach(zombie => {
                // Calculate relative position to player
                const relativeX = zombie.position.x - camera.position.x;
                const relativeZ = zombie.position.z - camera.position.z;
                
                // Scale position to fit minimap (1 unit = 5 pixels)
                const mapX = (relativeX * 5) + centerX;
                const mapY = (relativeZ * 5) + centerY;
                
                // Check if zombie is within minimap radius
                const distance = Math.sqrt(
                    Math.pow(mapX - centerX, 2) + 
                    Math.pow(mapY - centerY, 2)
                );
                
                if (distance < radarRadius) {
                    // Draw zombie dot with different colors based on type
                    if (zombie.userData.isRobot) {
                        minimapCtx.fillStyle = '#ff9900'; // Orange for robots
                    } else if (zombie.userData.isToughZombie) {
                        minimapCtx.fillStyle = '#ff0000'; // Red for tough zombies
                    } else if (zombie.userData.isCrawler) {
                        minimapCtx.fillStyle = '#ff9900'; // Orange for crawlers
                    } else {
                        minimapCtx.fillStyle = '#ff6666'; // Light red for regular zombies
                    }
                    
                    minimapCtx.beginPath();
                    minimapCtx.arc(mapX, mapY, 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
        }
        
        // Update fire animation and handle healing
        function updateCampfire(delta) {
            if (!campfire) return;
            
            // Animate fire cubes
            const fireGroup = campfire.userData.fireGroup;
            fireGroup.children.forEach((cube) => {
                // Float up and down
                cube.userData.phase += cube.userData.floatSpeed * delta;
                cube.position.y = cube.userData.originalHeight + Math.sin(cube.userData.phase) * 0.3;
                
                // Rotate slowly
                cube.rotation.x += cube.userData.rotationSpeed * delta;
                cube.rotation.y += cube.userData.rotationSpeed * 1.5 * delta;
                
                // Pulse intensity
                const material = cube.material;
                const intensity = 1.0 + 0.5 * Math.sin(cube.userData.phase * 2);
                material.emissiveIntensity = intensity;
            });
            
            // Check if player is close to campfire for healing
            const distanceToCampfire = camera.position.distanceTo(healingStation.position);
            
            if (distanceToCampfire < healingStation.radius && playerHealth < 100) {
                // Heal player
                playerHealth += healingStation.healAmount * delta;
                if (playerHealth > 100) playerHealth = 100;
                
                // Update health display
                document.getElementById('health').textContent = `Health: ${Math.floor(playerHealth)}`;
                
                // Add particle effect or sound for healing feedback here if desired
            }
        }
        
        // Add dynamic environment generation
        let worldBoundary = 100; // Initial world boundary (smaller to trigger generation sooner)
        let lastPlayerPosition = new THREE.Vector3();
        
        // Store generated environment objects
        const environmentObjects = [];
        const maxEnvironmentObjects = 2000; // More reasonable limit for performance
        
        // Store a reference to rockMaterial globally
        const rockMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xaaaaaa, 
            roughness: 0.8,
            metalness: 0.2
        });
        
        // Create custom rock geometry function
        function createCustomRockGeometry() {
            const geometry = new THREE.BufferGeometry();
            
            // Vertices for a rock with flat bottom and angled facets
            const vertices = new Float32Array([
                // Bottom face (flat)
                -1.0, 0.0, -1.0,
                1.0, 0.0, -1.0,
                1.0, 0.0, 1.0,
                -1.0, 0.0, 1.0,
                
                // Top vertex
                0.0, 1.5, 0.0,
                
                // Mid-height vertices for facets
                -0.7, 0.8, -0.7,
                0.7, 0.8, -0.7,
                0.7, 0.8, 0.7,
                -0.7, 0.8, 0.7,
                
                // Additional vertices for more complex shape
                -0.4, 1.2, 0.0,
                0.4, 1.2, 0.0,
                0.0, 1.2, -0.4,
                0.0, 1.2, 0.4
            ]);
            
            // Faces (triangles)
            const indices = [
                // Bottom face
                0, 1, 2,
                0, 2, 3,
                
                // Side facets - lower section
                0, 5, 1,
                1, 6, 2,
                2, 7, 3,
                3, 8, 0,
                
                // Side facets connecting to mid-height
                5, 6, 1,
                6, 7, 2,
                7, 8, 3,
                8, 5, 0,
                
                // Upper facets
                5, 9, 6,
                6, 10, 7,
                7, 11, 8,
                8, 12, 5,
                
                // Top facets
                9, 4, 10,
                10, 4, 11,
                11, 4, 12,
                12, 4, 9
            ];
            
            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.computeVertexNormals();
            
            return geometry;
        }
        
        // Define/redefine tree function
        function createStylizedTree(size = 1, foliageColor = null) {
            const treeGroup = new THREE.Group();
            
            // Create trunk with reddish-brown color
            const trunkHeight = 1.5 * size;
            const trunkGeometry = new THREE.CylinderGeometry(0.2 * size, 0.3 * size, trunkHeight, 5);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: new THREE.Color(Math.random() * 0.1 + 0.6, Math.random() * 0.1 + 0.2, 0), // Reddish-brown variations
                roughness: 0.8,
                metalness: 0.2
            });
            
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);
            
            // Create foliage
            function createBulbousFoliage(size = 1, colorOverride = null) {
                // Create low-poly bulbous foliage with custom geometry
                const geometry = new THREE.IcosahedronGeometry(size, 0);
                
                // Slightly deform the geometry to make it less perfect
                const positions = geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    
                    // Add random displacement
                    positions.setX(i, x + (Math.random() - 0.5) * 0.2 * size);
                    positions.setY(i, y + (Math.random() - 0.5) * 0.2 * size);
                    positions.setZ(i, z + (Math.random() - 0.5) * 0.2 * size);
                }
                
                // Update the geometry
                geometry.computeVertexNormals();
                
                // Create bright green material for foliage
                const color = colorOverride || new THREE.Color(
                    Math.random() * 0.2 + 0.6, // Higher green value
                    Math.random() * 0.2 + 0.8, // Bright green with variations
                    Math.random() * 0.1       // Small blue component
                );
                
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    flatShading: true, // Important for the low-poly look
                    roughness: 0.8,
                    metalness: 0.1
                });
                
                const foliage = new THREE.Mesh(geometry, material);
                foliage.castShadow = true;
                
                return foliage;
            }
            
            // Add branches
            const branchCount = Math.floor(Math.random() * 2) + 1;
            for (let i = 0; i < branchCount; i++) {
                const branchLength = (Math.random() * 0.5 + 0.5) * size;
                const branchGeometry = new THREE.CylinderGeometry(0.05 * size, 0.1 * size, branchLength, 4);
                const branch = new THREE.Mesh(branchGeometry, trunkMaterial);
                
                // Position branch
                const branchHeight = Math.random() * 0.5 + 0.5;
                const angle = Math.random() * Math.PI * 2;
                branch.position.y = trunkHeight * branchHeight;
                branch.position.x = Math.cos(angle) * 0.2 * size;
                branch.position.z = Math.sin(angle) * 0.2 * size;
                
                // Rotate branch
                branch.rotation.x = Math.PI / 2 - Math.random() * 0.5;
                branch.rotation.y = angle;
                branch.castShadow = true;
                treeGroup.add(branch);
                
                // Add small foliage clusters to branches
                const smallFoliage = createBulbousFoliage(size * 0.4, foliageColor);
                smallFoliage.position.set(
                    branch.position.x + Math.cos(angle) * branchLength * 0.5,
                    branch.position.y + Math.sin(branch.rotation.x) * branchLength * 0.5,
                    branch.position.z + Math.sin(angle) * branchLength * 0.5
                );
                treeGroup.add(smallFoliage);
            }
            
            // Create main bulbous foliage on top
            const foliage = createBulbousFoliage(size, foliageColor);
            foliage.position.y = trunkHeight + 0.5 * size;
            treeGroup.add(foliage);
            
            return treeGroup;
        }
        
        // Define/redefine bush function
        function createBush(size = 1.0) {
            const bushGroup = new THREE.Group();
            
            // Create 1-3 bulbous parts for the bush
            const bulbCount = Math.floor(Math.random() * 3) + 1;
            
            for (let i = 0; i < bulbCount; i++) {
                // Create a bulbous shape for each part
                const bulbSize = (Math.random() * 0.3 + 0.2) * size;
                const geometry = new THREE.IcosahedronGeometry(bulbSize, 0);
                
                // Deform slightly
                const positions = geometry.attributes.position;
                for (let v = 0; v < positions.count; v++) {
                    const x = positions.getX(v);
                    const y = positions.getY(v);
                    const z = positions.getZ(v);
                    
                    positions.setX(v, x + (Math.random() - 0.5) * 0.1 * bulbSize);
                    positions.setY(v, y + (Math.random() - 0.5) * 0.1 * bulbSize);
                    positions.setZ(v, z + (Math.random() - 0.5) * 0.1 * bulbSize);
                }
                
                geometry.computeVertexNormals();
                
                // Create material with variations of green
                const greenShade = Math.random() * 0.2 + 0.3; // Darker than trees
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(greenShade * 0.6, greenShade, greenShade * 0.4),
                    flatShading: true,
                    roughness: 0.8
                });
                
                const bulb = new THREE.Mesh(geometry, material);
                
                // Position randomly around the center, but keep the bush low to the ground
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.15 * size;
                bulb.position.set(
                    Math.cos(angle) * radius,
                    bulbSize * 0.5, // Position half-buried to look connected to ground
                    Math.sin(angle) * radius
                );
                
                bushGroup.add(bulb);
            }
            
            return bushGroup;
        }
        
        // Define/redefine grass clump function
        function createGrassClump(size = 1.0) {
            const grassGroup = new THREE.Group();
            
            // Create multiple grass blades for each clump
            const bladeCount = Math.floor(Math.random() * 5) + 8;
            
            for (let i = 0; i < bladeCount; i++) {
                // Create tapered blade shape
                const bladeHeight = (Math.random() * 0.2 + 0.1) * size;
                const bottomWidth = 0.05 * size;
                const topWidth = 0.01 * size;
                
                const bladeGeometry = new THREE.BufferGeometry();
                const vertices = new Float32Array([
                    // Left side
                    -bottomWidth/2, 0, 0,
                    -topWidth/2, bladeHeight, 0,
                    bottomWidth/2, 0, 0,
                    
                    // Right side
                    bottomWidth/2, 0, 0,
                    -topWidth/2, bladeHeight, 0,
                    topWidth/2, bladeHeight, 0
                ]);
                
                bladeGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                bladeGeometry.computeVertexNormals();
                
                // Vary the grass colors slightly
                const greenShade = Math.random() * 0.15 + 0.35;
                const blade = new THREE.Mesh(
                    bladeGeometry,
                    new THREE.MeshStandardMaterial({
                        color: new THREE.Color(0.2, greenShade, 0.1),
                        side: THREE.DoubleSide,
                        flatShading: true
                    })
                );
                
                // Position and rotate blade within the clump
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.1 * size;
                blade.position.set(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );
                
                // Random rotation and slight curve
                blade.rotation.y = Math.random() * Math.PI * 2;
                blade.rotation.x = Math.random() * 0.2;
                
                // Add small random offset
                blade.position.y += Math.random() * 0.01;
                
                grassGroup.add(blade);
            }
            
            return grassGroup;
        }
        
        // Initialize dynamic environment generation with starting areas
        function initializeEnvironment() {
            // Generate initial areas around the player - but fewer and more spread out
            for (let x = -1; x <= 1; x += 2) { // Skip middle values to spread things out
                for (let z = -1; z <= 1; z += 2) {
                    const areaX = x * 50; // More spread out (was 30)
                    const areaZ = z * 50; // More spread out (was 30)
                    generateEnvironmentInArea(areaX, areaZ, 30);
                }
            }
            
            // Set the initial player position for expansion checks
            lastPlayerPosition.copy(camera.position);
        }
        
        // Object spacing management - keep track of occupied positions
        const occupiedPositions = [];
        
        // Check if a position is too close to existing objects
        function isPositionOccupied(x, z, minDistance = 8, onlyCheckGenerationPoints = false) {
            for (const pos of occupiedPositions) {
                // Skip if we only want to check generation points and this isn't one
                if (onlyCheckGenerationPoints && !pos.isGenerationPoint) {
                    continue;
                }
                
                const dx = pos.x - x;
                const dz = pos.z - z;
                const distanceSquared = dx * dx + dz * dz;
                if (distanceSquared < minDistance * minDistance) {
                    return true; // Position is too close to an existing object
                }
            }
            return false; // Position is available
        }
        
        function generateEnvironmentInArea(centerX, centerZ, radius) {
            console.log(`Generating environment at x:${centerX.toFixed(1)}, z:${centerZ.toFixed(1)} with radius ${radius}`);
            
            // Slightly increase object counts to ensure some objects appear
            const objectCount = {
                trees: Math.floor(Math.random() * 2) + 2,     // 2-3 trees
                bushes: Math.floor(Math.random() * 2) + 1,    // Reduced: 1-2 bushes (was 2-4)
                rocks: Math.floor(Math.random() * 2) + 2,     // 2-3 rocks
                grassPatches: Math.floor(Math.random() * 4) + 4 // 4-7 grass patches
            };
            
            // Check if this area already has substantial objects
            const existingObjectsInArea = environmentObjects.filter(obj => {
                const dx = obj.position.x - centerX;
                const dz = obj.position.z - centerZ;
                return (dx * dx + dz * dz) < (radius * radius);
            });
            
            // Skip generation if area already has objects
            if (existingObjectsInArea.length > 5) {
                console.log(`Area at x:${centerX.toFixed(1)}, z:${centerZ.toFixed(1)} already populated, skipping`);
                return;
            }
            
            // Generate trees - with more spacing
            for (let i = 0; i < objectCount.trees; i++) {
                // Try multiple positions until we find an unoccupied one
                let placementAttempts = 0;
                let placed = false;
                
                while (placementAttempts < 10 && !placed) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * radius;
                    const x = centerX + Math.cos(angle) * distance;
                    const z = centerZ + Math.sin(angle) * distance;
                    
                    // Don't place trees too close to player
                    if (Math.sqrt(x * x + z * z) < 15) {
                        placementAttempts++;
                        continue;
                    }
                    
                    // Check if position is already occupied
                    if (isPositionOccupied(x, z, 12)) { // Trees need more space
                        placementAttempts++;
                        continue;
                    }
                    
                    const treeSize = Math.random() * 1.5 + 0.8;
                    
                    // Randomly select one of two foliage color variations
                    let foliageColor = null;
                    const colorVariation = Math.random();
                    if (colorVariation > 0.6) {
                        // Yellow-green variation
                        foliageColor = new THREE.Color(0.8, 0.9, 0.2);
                    } else if (colorVariation > 0.3) {
                        // Standard green variation
                        foliageColor = new THREE.Color(0.4, 0.8, 0.2);
                    }
                    
                    const tree = createStylizedTree(treeSize, foliageColor);
                    tree.position.set(x, 0, z);
                    tree.rotation.y = Math.random() * Math.PI * 2;
                    scene.add(tree);
                    
                    // Mark position as occupied
                    occupiedPositions.push({x, z, radius: 10});
                    
                    environmentObjects.push({
                        object: tree,
                        type: 'tree',
                        position: new THREE.Vector3(x, 0, z)
                    });
                    
                    placed = true;
                }
            }
            
            // Generate bushes - with spacing
            for (let i = 0; i < objectCount.bushes; i++) {
                let placementAttempts = 0;
                let placed = false;
                
                while (placementAttempts < 10 && !placed) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * radius;
                    const x = centerX + Math.cos(angle) * distance;
                    const z = centerZ + Math.sin(angle) * distance;
                    
                    // Don't place bushes too close to player
                    if (Math.sqrt(x * x + z * z) < 10) {
                        placementAttempts++;
                        continue;
                    }
                    
                    // Check if position is already occupied
                    if (isPositionOccupied(x, z, 8)) {
                        placementAttempts++;
                        continue;
                    }
                    
                    const bush = createBush(Math.random() * 1.0 + 0.6); // Reduced size range (was 0.8 to 2.3, now 0.6 to 1.6)
                    bush.position.set(x, 0, z);
                    bush.rotation.y = Math.random() * Math.PI * 2;
                    scene.add(bush);
                    
                    // Mark position as occupied
                    occupiedPositions.push({x, z, radius: 6});
                    
                    environmentObjects.push({
                        object: bush,
                        type: 'bush',
                        position: new THREE.Vector3(x, 0, z)
                    });
                    
                    placed = true;
                }
            }
            
            // Generate rocks - with spacing
            for (let i = 0; i < objectCount.rocks; i++) {
                let placementAttempts = 0;
                let placed = false;
                
                while (placementAttempts < 10 && !placed) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * radius;
                    const x = centerX + Math.cos(angle) * distance;
                    const z = centerZ + Math.sin(angle) * distance;
                    
                    // Don't place rocks too close to player
                    if (Math.sqrt(x * x + z * z) < 8) {
                        placementAttempts++;
                        continue;
                    }
                    
                    // Check if position is already occupied
                    if (isPositionOccupied(x, z, 7)) {
                        placementAttempts++;
                        continue;
                    }
                    
                    const rockGeometry = createCustomRockGeometry();
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    rock.position.set(x, 0, z);
                    
                    // Random scale
                    const scale = Math.random() * 1 + 0.5;
                    rock.scale.set(scale, scale * 0.8, scale);
                    
                    // Random rotation around Y axis
                    rock.rotation.y = Math.random() * Math.PI * 2;
                    scene.add(rock);
                    
                    // Mark position as occupied
                    occupiedPositions.push({x, z, radius: 5});
                    
                    environmentObjects.push({
                        object: rock,
                        type: 'rock',
                        position: new THREE.Vector3(x, 0, z)
                    });
                    
                    placed = true;
                }
            }
            
            // Generate grass patches - these can be closer together
            for (let i = 0; i < objectCount.grassPatches; i++) {
                let placementAttempts = 0;
                let placed = false;
                
                while (placementAttempts < 5 && !placed) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * radius;
                    const x = centerX + Math.cos(angle) * distance;
                    const z = centerZ + Math.sin(angle) * distance;
                    
                    // Check if position is already occupied by larger objects
                    if (isPositionOccupied(x, z, 4)) {
                        placementAttempts++;
                        continue;
                    }
                    
                    const grass = createGrassClump(Math.random() * 1.5 + 1.0);
                    grass.position.set(x, 0, z);
                    grass.rotation.y = Math.random() * Math.PI * 2;
                    scene.add(grass);
                    
                    // Grass doesn't block other objects, so we don't mark it in occupiedPositions
                    
                    environmentObjects.push({
                        object: grass,
                        type: 'grass',
                        position: new THREE.Vector3(x, 0, z)
                    });
                    
                    placed = true;
                }
            }
            
            // Clean up distant objects if we exceed the maximum
            if (environmentObjects.length > maxEnvironmentObjects) {
                const playerPos = camera.position;
                // Sort by distance to player
                environmentObjects.sort((a, b) => 
                    a.position.distanceTo(playerPos) - b.position.distanceTo(playerPos)
                );
                
                // Remove the most distant objects
                const objectsToRemove = environmentObjects.splice(
                    maxEnvironmentObjects, 
                    environmentObjects.length - maxEnvironmentObjects
                );
                
                objectsToRemove.forEach(item => {
                    scene.remove(item.object);
                    
                    // Also remove from occupied positions tracking
                    const index = occupiedPositions.findIndex(pos => 
                        Math.abs(pos.x - item.position.x) < 0.1 && 
                        Math.abs(pos.z - item.position.z) < 0.1
                    );
                    
                    if (index !== -1) {
                        occupiedPositions.splice(index, 1);
                    }
                });
            }
        }
        
        function checkAndExpandWorld() {
            const playerPos = camera.position;
            const distanceFromLastCheck = playerPos.distanceTo(lastPlayerPosition);
            
            // Only check if player has moved a significant distance - decreased from 15 to 10
            if (distanceFromLastCheck > 10) {
                lastPlayerPosition.copy(playerPos);
                
                // Check if the player is in an empty area
                const nearbyObjects = environmentObjects.filter(obj => {
                    const dx = obj.position.x - playerPos.x;
                    const dz = obj.position.z - playerPos.z;
                    // Check in a 30-unit radius around player
                    return (dx * dx + dz * dz) < (30 * 30);
                });
                
                // If player is in an empty area (fewer than 3 objects nearby), generate objects around them
                if (nearbyObjects.length < 3) {
                    console.log("Player in empty area - generating environment");
                    
                    // Generate objects in a circle around the player, but not too close
                    const playerAreaRadius = 40;
                    
                    // Generate 2-4 clusters around the player
                    const numClusters = Math.floor(Math.random() * 3) + 2;
                    for (let i = 0; i < numClusters; i++) {
                        // Generate at a distance from the player, but within view distance
                        const angle = Math.random() * Math.PI * 2;
                        // Position between 20-40 units away
                        const distance = 20 + Math.random() * 20;
                        const areaX = playerPos.x + Math.cos(angle) * distance;
                        const areaZ = playerPos.z + Math.sin(angle) * distance;
                        
                        // Only generate if no other generation point is nearby
                        if (!isPositionOccupied(areaX, areaZ, 25, true)) {
                            generateEnvironmentInArea(areaX, areaZ, 20);
                            
                            // Mark this area as having been generated
                            occupiedPositions.push({
                                x: areaX, 
                                z: areaZ, 
                                radius: 25, 
                                isGenerationPoint: true
                            });
                        }
                    }
                }
                
                // Still generate in player's direction of travel as before
                const movementDirection = new THREE.Vector3()
                    .subVectors(playerPos, lastPlayerPosition)
                    .normalize();
                
                // Add some randomness to direction to create more natural distribution
                const randomAngle = (Math.random() - 0.5) * Math.PI / 2; // +/- 45 degrees
                const randomizedDirection = movementDirection.clone()
                    .applyAxisAngle(new THREE.Vector3(0, 1, 0), randomAngle)
                    .multiplyScalar(50); // Generate 50 units ahead
                
                const newAreaX = playerPos.x + randomizedDirection.x;
                const newAreaZ = playerPos.z + randomizedDirection.z;
                
                // Only generate if we're far enough from previous generation points
                if (!isPositionOccupied(newAreaX, newAreaZ, 30, true)) {
                    generateEnvironmentInArea(newAreaX, newAreaZ, 35);
                    
                    // Mark this area as having been generated
                    occupiedPositions.push({
                        x: newAreaX, 
                        z: newAreaZ, 
                        radius: 30, 
                        isGenerationPoint: true
                    });
                }
                
                // Expand world boundary
                worldBoundary = Math.max(
                    worldBoundary,
                    Math.abs(playerPos.x) + 100,
                    Math.abs(playerPos.z) + 100
                );
            }
        }
        
        // Game loop
        function animate() {
            if (isTransitioning) {
                requestAnimationFrame(animate); // Keep rendering but skip updates
                renderer.render(scene, camera);
                return;
            }
            // ... rest of your animate function ...
        
            requestAnimationFrame(animate);
            
            // Skip updates if game hasn't started or is over
            if (!gameStarted || isGameOver) return;
            
            // Get elapsed time (only calculate delta when game is running)
            const time = performance.now();
            const delta = (time - prevTime) / 1000; // in seconds
            prevTime = time; // Update prevTime here
            
            // --- Only update game logic and timers when game is active ---
            
            // Update game time and check for day/night transition
            gameTime += delta;

            // Debug log to track when boss fight should trigger
            console.log(`gameTime: ${Math.floor(gameTime)}, currentWave: ${currentWave}, isBossFight: ${isBossFight}`);
            
            // Check for wave transitions (also depends on gameTime)
            if (gameTime >= 400 && currentWave === 3 && !isBossFight) {
                console.log("BOSS FIGHT TRIGGERED!");
                currentWave = 4;
                
                // Keep other enemies present during boss fight - don't clear them
                
                // Trigger boss fight
                showWaveMessage("BOSS FIGHT");
                waveMessageTimer = 3; // Set timer to 3 seconds
                isBossFight = true;
                spawnBossZombie();
            } else if (gameTime >= 240 && currentWave === 2) {
                currentWave = 3;
                showWaveMessage("WAVE 3");
                waveMessageTimer = 3; // Set timer to 3 seconds
                
                // Spawn robot enemies to announce wave 3
                for (let i = 0; i < 2; i++) {
                    spawnRobot();
                }
            } else if (gameTime >= 180 && currentWave === 1) {
                currentWave = 2;
                showWaveMessage("WAVE 2");
                waveMessageTimer = 3; // Set timer to 3 seconds
                
                // Spawn a few tough zombies to announce wave 2
                for (let i = 0; i < 3; i++) {
                    spawnZombie(true); // Spawn tough zombies
                }
            }
            
            // Update wave message timer if active
            if (waveMessageTimer > 0) {
                waveMessageTimer -= delta;
                if (waveMessageTimer <= 0 && waveMessage) {
                    waveMessage.parentNode.removeChild(waveMessage);
                    waveMessage = null;
                }
            }
            
            // Update robot lasers
            updateRobotLasers(delta);
            
            // Make robots shoot periodically
            if (currentWave >= 3) {
                robots.forEach(robot => {
                    // Only shoot if player is in range and robot has a cooldown timer
                    if (robot.userData.shootCooldown !== undefined) {
                        // Reduce cooldown timer
                        robot.userData.shootCooldown -= delta;
                        
                        // When cooldown is complete, shoot if player is in range
                        if (robot.userData.shootCooldown <= 0 && 
                            robot.position.distanceTo(camera.position) < 30) {
                            
                            // Reset cooldown
                            robot.userData.shootCooldown = Math.random() * 2 + 2; // 2-4 seconds
                            
                            // Shoot laser
                            shootRobotLaser(robot);
                        }
                    }
                });
            }
            
            if (gameTime >= 600 && !isNight) { // 600 seconds = 10 minutes
                transitionToNight();
            }
            
            // Move sun or moon in sky
            if (!isNight && skybox.sun) {
                // Simple sun rotation effect
                const angle = (gameTime / 600) * Math.PI; // Full arc over 10 minutes
                skybox.sun.position.x = Math.cos(angle) * 300;
                skybox.sun.position.y = Math.sin(angle) * 200 + 50;
                
                // Update sunrays position and visibility
                if (sunrays) {
                    sunrays.position.copy(skybox.sun.position);
                    
                    // Fade sunrays based on sun height
                    const sunHeight = skybox.sun.position.y / 250;
                    sunrays.material.opacity = Math.min(1, Math.max(0, sunHeight));
                }
            } else if (isNight && skybox.moon) {
                // Simple moon movement
                const nightTime = gameTime - 600; // Time since night started
                const angle = (nightTime / 600) * Math.PI; 
                skybox.moon.position.x = Math.cos(angle) * 300;
                skybox.moon.position.y = Math.sin(angle) * 200 + 50;
                
                // Hide sunrays at night
                if (sunrays) sunrays.visible = false;
                
                // Update moonrays position and visibility
                if (moonrays) {
                    moonrays.position.copy(skybox.moon.position);
                    moonrays.visible = true;
                    
                    // Fade moonrays based on moon height
                    const moonHeight = skybox.moon.position.y / 250;
                    moonrays.material.opacity = Math.min(0.5, Math.max(0, moonHeight));
                }
            }
            
            // Update clouds
            if (!isNight) {
                clouds.forEach(cloud => {
                    cloud.position.x += cloud.userData.direction.x * cloud.userData.speed;
                    cloud.position.z += cloud.userData.direction.z * cloud.userData.speed;
                    
                    // Wrap clouds around when they go too far
                    const limit = 400;
                    if (cloud.position.x > limit) cloud.position.x = -limit;
                    if (cloud.position.x < -limit) cloud.position.x = limit;
                    if (cloud.position.z > limit) cloud.position.z = -limit;
                    if (cloud.position.z < -limit) cloud.position.z = limit;
                    
                    // Slow rotation for realism
                    cloud.rotation.y += 0.001;
                });
            }
            
            // Update birds
            if (!isNight) {
                birds.forEach(bird => {
                    // Move bird
                    bird.position.x += bird.userData.direction.x * bird.userData.speed;
                    bird.position.z += bird.userData.direction.z * bird.userData.speed;
                    
                    // Make bird face movement direction
                    bird.lookAt(
                        bird.position.x + bird.userData.direction.x, 
                        bird.position.y, 
                        bird.position.z + bird.userData.direction.z
                    );
                    
                    // Wing flapping animation
                    bird.userData.wingPhase += bird.userData.wingSpeed;
                    const leftWing = bird.getObjectByName('leftWing');
                    const rightWing = bird.getObjectByName('rightWing');
                    if (leftWing && rightWing) {
                        leftWing.rotation.z = Math.sin(bird.userData.wingPhase) * 0.5;
                        rightWing.rotation.z = -Math.sin(bird.userData.wingPhase) * 0.5;
                    }
                    
                    // Wrap birds around when they go too far
                    const limit = 500;
                    if (bird.position.x > limit) bird.position.x = -limit;
                    if (bird.position.x < -limit) bird.position.x = limit;
                    if (bird.position.z > limit) bird.position.z = -limit;
                    if (bird.position.z < -limit) bird.position.z = limit;
                    
                    // Random altitude changes
                    if (Math.random() < 0.01) {
                        bird.position.y += (Math.random() * 2 - 1) * 5;
                        bird.position.y = Math.max(100, Math.min(200, bird.position.y));
                    }
                    
                    // Random direction changes
                    if (Math.random() < 0.005) {
                        bird.userData.direction.x = Math.random() * 2 - 1;
                        bird.userData.direction.z = Math.random() * 2 - 1;
                        bird.userData.direction.normalize();
                    }
                });
            }
            
            // Update campfire and handle healing
            updateCampfire(delta);
            
            // Update minimap
            updateMinimap();
            
            // Check if we need to expand the world
            checkAndExpandWorld();
            
            // Update active powerups (e.g., make them float, rotate)
            updateActivePowerups(delta);
            
            // Update active grenades
            updateActiveGrenades(delta);
            
            // Update player movement
            velocity.x = 0;
            velocity.z = 0;
            
            // Check if player is moving
            const wasMoving = isMoving;
            isMoving = moveForward || moveBackward || moveLeft || moveRight;
            
            // Calculate movement vector
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();
            
            // Set movement speed based on running state
            const walkingSpeed = 35.0; // Decreased walking speed (was 45.0)
            const runningSpeed = 120.0; // Faster running speed
            const moveSpeed = isRunning ? runningSpeed : walkingSpeed;
            
            if (moveForward || moveBackward) velocity.z -= direction.z * moveSpeed * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * moveSpeed * delta;
            
            // Only consider player moving if there's actual velocity
            const actuallyMoving = (Math.abs(velocity.x) > 0.1 || Math.abs(velocity.z) > 0.1);
            isMoving = isMoving && actuallyMoving;
            
            // If player starts moving, play footstep
            if (isMoving && !wasMoving) {
                lastFootstepTime = time; // Reset footstep timer
            }
            
            // Play footstep sounds when moving - faster when running
            if (isMoving) {
                // Adjust footstep interval for running
                const footstepInterval = isRunning ? FOOTSTEP_INTERVAL * 0.6 : FOOTSTEP_INTERVAL;
                
                if (time - lastFootstepTime >= footstepInterval) {
                    playFootstep();
                    lastFootstepTime = time;
                }
            }
               // Handle jumping physics
   if (isJumping) {
       // Apply vertical movement based on jump velocity
       camera.position.y += jumpVelocity * delta;
       
       // Apply gravity to reduce jump velocity
       jumpVelocity -= gravity * delta;
       
       // Check if player has landed
       if (camera.position.y <= playerHeight) {
           // Reset position and jump state
           camera.position.y = playerHeight;
           isJumping = false;
           jumpVelocity = 0;
       }
   } else {
       // Keep player at standard height when not jumping
       camera.position.y = playerHeight;
   }
            
            // Apply rotation to movement
            const movementVector = new THREE.Vector3(-velocity.x * delta, 0, -velocity.z * delta);
            movementVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);
            
            // Limit camera tilt
            const maxTilt = 0.1; // Maximum tilt angle in radians
            camera.rotation.z = Math.max(-maxTilt, Math.min(maxTilt, camera.rotation.z));
            
            camera.position.add(movementVector);
            
            // Update zombies
            zombies.forEach(zombie => {
                // Make zombie face player
                const zombieToPlayer = new THREE.Vector3(
                    camera.position.x - zombie.position.x,
                    0,
                    camera.position.z - zombie.position.z
                ).normalize();
                
                zombie.lookAt(camera.position.x, zombie.position.y, camera.position.z);
                
                // Move zombie toward player
                zombie.position.x += zombieToPlayer.x * zombie.userData.speed * delta * 60;
                zombie.position.z += zombieToPlayer.z * zombie.userData.speed * delta * 60;
                
                // Animation
                zombie.userData.animationPhase += 0.2;
                
                // Apply bobbing animation to all zombies
                zombie.position.y = Math.sin(zombie.userData.animationPhase) * 0.1;
                
                // Rotate arms and legs for walking animation
                zombie.traverse(child => {
                    if (child.name === 'leftArm') {
                        child.rotation.x = Math.sin(zombie.userData.animationPhase) * 0.5;
                    } else if (child.name === 'rightArm') {
                        child.rotation.x = -Math.sin(zombie.userData.animationPhase) * 0.5;
                    } else if (child.name === 'leftLeg') {
                        child.rotation.x = -Math.sin(zombie.userData.animationPhase) * 0.5;
                    } else if (child.name === 'rightLeg') {
                        child.rotation.x = Math.sin(zombie.userData.animationPhase) * 0.5;
                    }
                });
                
                // Check for collision with player
                if (zombie.position.distanceTo(camera.position) < 1.5) {
                    // Different damage for different enemy types
                    let damage = 1; // Default for small zombies
                    
                    if (zombie.userData.isToughZombie) {
                        damage = 5; // Tough zombies
                    } else if (zombie.userData.isRobot) {
                        damage = 0; // Robots deal damage with lasers, not collision
                    } else if (zombie.userData.isBoss) {
                        damage = 50; // Boss zombie deals massive damage
                    }
                    
                    playerHealth -= damage;
                    document.getElementById('health').textContent = `Health: ${playerHealth}`;
                    
                    if (playerHealth <= 0) {
                        gameOver();
                    }
                }
            });
            
            // Update bullets - optimized for performance
            const bulletCleanupThreshold = 30; // Only run full cleanup every 30 frames
            if (bullets.length > 0) {
                // Fast update for all bullets
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    bullet.position.add(bullet.userData.velocity);
                    bullet.userData.lifespan--;
                    
                    // Only check for removal every few frames unless we have too many bullets
                    if (bullet.userData.lifespan <= 0 || (bullets.length > 50 && Math.random() < 0.3)) {
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                    }
                }
            }
            
            // Update poison projectiles
            if (poisonProjectiles.length > 0) {
                for (let i = poisonProjectiles.length - 1; i >= 0; i--) {
                    const projectile = poisonProjectiles[i];
                    
                    // Move projectile
                    projectile.position.add(projectile.userData.velocity);
                    projectile.userData.lifespan--;
                    
                    // Update trail particles if they exist
                    if (projectile.userData.trailParticles) {
                        projectile.userData.trailParticles.forEach(particle => {
                            // Make particles follow behind main projectile
                            particle.position.copy(projectile.position);
                            particle.position.add(projectile.userData.velocity.clone().multiplyScalar(particle.userData.offset));
                        });
                    }
                    
                    // Check collision with player
                    if (projectile.position.distanceTo(camera.position) < 1.5) {
                        // Apply poison effect
                        applyPoisonEffect();
                        
                        // Remove projectile
                        scene.remove(projectile);
                        
                        // Remove trail particles
                        if (projectile.userData.trailParticles) {
                            projectile.userData.trailParticles.forEach(particle => {
                                scene.remove(particle);
                            });
                        }
                        
                        poisonProjectiles.splice(i, 1);
                        continue;
                    }
                    
                    // Remove expired projectiles
                    if (projectile.userData.lifespan <= 0) {
                        scene.remove(projectile);
                            // Update poison effect on player

                        // Remove trail particles
                        if (projectile.userData.trailParticles) {
                            projectile.userData.trailParticles.forEach(particle => {
                                scene.remove(particle);
                            });
                        }
                        
                        poisonProjectiles.splice(i, 1);
                    }
                }
            }
            
            // Update poison effect on player
            if (isPoisoned) {
                poisonTimeRemaining -= delta;
                poisonDamageTimer += delta;
                
                // Apply damage every second
                if (poisonDamageTimer >= 1) {
                    playerHealth -= 1; // Lose 1 health per second
                    document.getElementById('health').textContent = `Health: ${Math.floor(playerHealth)}`;
                    
                    // Flash the poison overlay to indicate damage
                    const poisonOverlay = document.getElementById('poisonOverlay');
                    if (poisonOverlay) {
                        poisonOverlay.style.backgroundColor = 'rgba(0, 255, 0, 0.2)'; // Brighter green
                        setTimeout(() => {
                            if (poisonOverlay) {
                                poisonOverlay.style.backgroundColor = 'rgba(0, 255, 0, 0.1)'; // Back to normal
                            }
                        }, 100);
                    }
                    
                    // Reset damage timer
                    poisonDamageTimer = 0;
                    
                    // Check for game over
                    if (playerHealth <= 0) {
                        gameOver();
                    }
                }
                
                // Remove poison effect when time is up
                if (poisonTimeRemaining <= 0) {
                    isPoisoned = false;
                    removePoisonEffect();
                    console.log("Poison effect has worn off");
                }
            }
            
            // Spawn new zombies occasionally if there are fewer than the limit and not in boss fight
            const maxEnemies = currentWave >= 3 ? 15 : 10;
            
            if (zombies.length < maxEnemies && Math.random() < 0.005) {
                if (currentWave === 1) {
                    // Wave 1: Only small zombies
                    spawnZombie(false);
                } else if (currentWave === 2) {
                    // Wave 2: Mix of small and tough zombies
                    const spawnToughZombie = Math.random() < 0.4; // 40% chance of tough zombie
                    spawnZombie(spawnToughZombie);
                } else if (currentWave === 3) {
                    // Wave 3: Mix of all enemy types
                    const rand = Math.random();
                    if (rand < 0.3) {
                        // 30% chance of a robot
                        spawnRobot();
                    } else if (rand < 0.6) {
                        // 30% chance of a tough zombie
                        spawnZombie(true);
                    } else {
                        // 40% chance of a small zombie
                        spawnZombie(false);
                    }
                }
            }
            
            // Update robots
            robots.forEach(robot => {
                // Hover effect
                robot.userData.hoverPhase += robot.userData.hoverSpeed * delta;
                robot.position.y = robot.userData.hoverHeight + Math.sin(robot.userData.hoverPhase) * 0.5;
                
                // Make robot face player
                robot.lookAt(camera.position.x, robot.position.y, camera.position.z);
                
                // Update flying pattern
                robot.userData.flyingPhase += robot.userData.flyingSpeed * delta * 5;
                
                // Calculate target position - flying in a circular pattern around the player
                // while maintaining distance
                const distanceToPlayer = robot.position.distanceTo(new THREE.Vector3(
                    camera.position.x, 0, camera.position.z
                ));
                
                // Determine movement behavior based on distance
                if (distanceToPlayer > 30) {
                    // If far from player, approach more directly
                    const robotToPlayer = new THREE.Vector3(
                        camera.position.x - robot.position.x,
                        0,
                        camera.position.z - robot.position.z
                    ).normalize();
                    
                    robot.position.x += robotToPlayer.x * robot.userData.speed * delta * 60;
                    robot.position.z += robotToPlayer.z * robot.userData.speed * delta * 60;
                } else if (distanceToPlayer < 15) {
                    // If too close, back away a bit
                    const playerToRobot = new THREE.Vector3(
                        robot.position.x - camera.position.x,
                        0,
                        robot.position.z - camera.position.z
                    ).normalize();
                    
                    robot.position.x += playerToRobot.x * robot.userData.speed * 0.8 * delta * 60;
                    robot.position.z += playerToRobot.z * robot.userData.speed * 0.8 * delta * 60;
                } else {
                    // Optimal distance - fly in a circular pattern
                    const angle = robot.userData.flyingPhase;
                    const radius = robot.userData.flyingPathRadius;
                    
                    // Calculate vector from player to robot
                    const playerToRobot = new THREE.Vector3(
                        robot.position.x - camera.position.x,
                        0,
                        robot.position.z - camera.position.z
                    ).normalize();
                    
                    // Calculate target point on circle around player
                    const targetX = camera.position.x + Math.cos(angle) * radius * playerToRobot.z 
                                  + Math.sin(angle) * radius * playerToRobot.x;
                    const targetZ = camera.position.z + Math.sin(angle) * radius * playerToRobot.z 
                                  - Math.cos(angle) * radius * playerToRobot.x;
                    
                    // Move toward that point
                    const moveVector = new THREE.Vector3(
                        targetX - robot.position.x,
                        0,
                        targetZ - robot.position.z
                    ).normalize();
                    
                    robot.position.x += moveVector.x * robot.userData.speed * 1.5 * delta * 60;
                    robot.position.z += moveVector.z * robot.userData.speed * 1.5 * delta * 60;
                }
                
                // More aggressive shooting
                if (robot.userData.shootCooldown !== undefined) {
                    // Reduce cooldown timer
                    robot.userData.shootCooldown -= delta;
                    
                    // When cooldown is complete, shoot if player is in range
                    if (robot.userData.shootCooldown <= 0 && 
                        distanceToPlayer < 40) {
                        
                        // Reset cooldown to exactly 3 seconds
                        robot.userData.shootCooldown = 3;
                        
                        // Shoot laser
                        shootRobotLaser(robot);
                    }
                }
            });
            
            prevTime = time;
            renderer.render(scene, camera);
            
            // Update weapon message timer if active
            if (weaponMessageTimer > 0) {
                weaponMessageTimer -= delta;
                if (weaponMessageTimer <= 0) {
                    if (weaponMessage) {
                        weaponMessage.style.opacity = 0;
                        setTimeout(() => {
                            if (weaponMessage && weaponMessage.parentNode) {
                                weaponMessage.parentNode.removeChild(weaponMessage);
                                weaponMessage = null;
                            }
                        }, 1000);
                    }
                }
            }

            // Inside the animate function:
            // Update boss health bar if it exists
                // Inside the check where boss health drops to 0 or below
if (bossZombie) { // <<< ADD THIS LINE
    if (bossZombie.userData.health <= 0 && !bossZombie.userData.isDead) {
        bossZombie.userData.isDead = true; // Prevent multiple triggers
        console.log("Boss Defeated!");

        if (currentRound === 1) {
            // Start Round 2 Transition instead of Game Over
            isTransitioning = true; // Pause game logic
            removeZombie(bossZombie); // Remove the boss mesh/group
            bossZombie = null; // Clear the global reference

            // Show Round 2 text for 15 seconds, then start Round 2
            showRoundText(2, 15000, () => {
                startRound(2);
            });

        } else {
            // Handle boss death in other rounds if needed, or game over
            gameOver();
        }
    }
            if (bossZombie && bossZombie.userData.healthBar) {
                // Update boss health bar to face camera
                bossZombie.userData.healthBarContainer.lookAt(camera.position);
                
                // Update health bar fill based on current health
                const healthPercent = bossZombie.userData.health / bossZombie.userData.initialHealth;
                bossZombie.userData.healthBar.scale.x = Math.max(0, healthPercent);
                
                // Position health bar fill to align with left edge
                bossZombie.userData.healthBar.position.x = -1 + healthPercent;
                
                // Handle boss poison attack
                if (bossZombie.userData.poisonAttackCooldown !== undefined) {
                    // Reduce cooldown timer
                    bossZombie.userData.poisonAttackCooldown -= delta;
                    
                    // When cooldown is complete, shoot poison if player is in range
                    if (bossZombie.userData.poisonAttackCooldown <= 0 && 
                        bossZombie.position.distanceTo(camera.position) < 50) {
                        
                        // Reset cooldown (random between 6-9 seconds)
                        bossZombie.userData.poisonAttackCooldown = Math.random() * 3 + 6;
                        
                        // Shoot poison
                        shootBossPoison();
                        console.log("Boss shooting poison!");
                    }
                }
                
                // Animate the boss
                bossZombie.userData.animationPhase += 0.08; // Slower animation for boss
                const phase = bossZombie.userData.animationPhase;
                // Increase swing factor for more pronounced movement
                const swingFactor = 0.25; 
                
                bossZombie.traverse(child => {
                    if (child.name === 'leftArm') {
                        if (child.userData.holdsChainsaw) {
                            // Hold chainsaw more steadily forward, less swing, slight tremble
                            child.rotation.x = Math.PI / 8 + Math.sin(phase * 3) * 0.04;
                            child.rotation.z = -Math.PI / 8 + Math.cos(phase * 3) * 0.02; 
                        } else {
                             child.rotation.x = Math.sin(phase) * swingFactor;
                        }
                    } else if (child.name === 'rightArm') {
                        child.rotation.x = -Math.sin(phase) * swingFactor; // Keep right arm swing
                    } else if (child.name === 'leftLeg') {
                         child.rotation.x = -Math.sin(phase) * swingFactor; // More pronounced leg swing
                    } else if (child.name === 'rightLeg') {
                         child.rotation.x = Math.sin(phase) * swingFactor;
                    } 
                });
            }
        }
    }
        
        // Game over function
        function gameOver() {
            isGameOver = true;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('restart').style.display = 'block';
            document.exitPointerLock();
        }
        
        // Restart game function
        function restartGame() {
            // Clear zombies
            zombies.forEach(zombie => {
                scene.remove(zombie);
            });
            zombies = [];
            
            // Clear robots
            robots.forEach(robot => {
                scene.remove(robot);
            });
            robots = [];
            
            // Clear bullets
            bullets.forEach(bullet => {
                scene.remove(bullet);
            });
            bullets = [];
            
            // Clear active powerups
            activePowerups.forEach(powerup => {
                scene.remove(powerup);
            });
            activePowerups = [];
            
            // Clear active grenades
            activeGrenades.forEach(grenade => {
                scene.remove(grenade);
            });
            activeGrenades = [];
            
            // Reset game state
            score = 0;
            playerHealth = 100;
            isGameOver = false;
            gameStarted = true; // Ensure the game stays running after restart
            gameTime = 0;
            isNight = false;
            currentWave = 1;
            grenadeCount = 0; // Reset grenade count
            
            // Reset weapon
            currentWeapon = 'pistol';
            shotgunAmmo = 100;
            sniperAmmo = 10;
            machineGunAmmo = 400;
            document.getElementById('ammo').textContent = weapons[currentWeapon].infiniteAmmo ? 'Ammo: ∞' : `Ammo: ${weapons[currentWeapon].ammo}`;
            
            // Reset UI
            document.getElementById('score').textContent = 'Score: 0';
            document.getElementById('health').textContent = 'Health: 100';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('restart').style.display = 'none';
            updateGrenadeDisplay(); // Update HUD on restart
            
            // Reset player position and camera
            camera.position.set(0, 1.5, 0);
            camera.rotation.set(0, 0, 0);
            velocity.set(0, 0, 0);
            
            // Lock pointer again
            document.body.requestPointerLock();
            
            // Spawn new zombies
            for (let i = 0; i < 5; i++) {
                spawnZombie(false);
            }
            
            // Show Wave 1 message
            showWaveMessage("WAVE 1");

            // Reset boss state
            bossZombie = null;
            isBossFight = false;
        }
        
        // Add new function for night transition
        function transitionToNight() {
            isNight = true;
            console.log("Transitioning to night...");
            
            // Create stars if they don't exist
            if (!skybox.stars) {
                skybox.stars = createStars();
                scene.add(skybox.stars);
                skybox.stars.visible = false;
            }
            
            // Transition parameters
            let fadeProgress = 0;
            const fadeDuration = 10; // 10 seconds transition for more dramatic effect
            
            const fadeInterval = setInterval(() => {
                fadeProgress += 0.016; // Approximately 60fps
                
                const progress = Math.min(fadeProgress / fadeDuration, 1.0);
                
                // Update lighting
                sunLight.intensity = Math.max(0, 1 - progress);
                moonLight.intensity = Math.min(0.3, progress * 0.3);
                moonLight.visible = progress > 0.5;
                
                // Update sun and moon visibility and position
                // Sun sets
                skybox.sun.position.y = 100 * (1 - progress);
                // Moon rises
                skybox.moon.position.y = 100 * progress;
                skybox.moon.visible = progress > 0.5;
                
                // Fade out sunrays and fade in moonrays
                if (sunrays) {
                    sunrays.material.opacity = Math.max(0, 0.7 - progress);
                    if (progress > 0.7) sunrays.visible = false;
                }
                
                if (moonrays) {
                    moonrays.visible = progress > 0.5;
                    moonrays.position.copy(skybox.moon.position);
                    moonrays.material.opacity = Math.min(0.5, Math.max(0, (progress - 0.5) * 2));
                }
                
                // Hide clouds and birds gradually
                clouds.forEach(cloud => {
                    cloud.traverse(child => {
                        if (child.material) {
                            child.material.opacity = Math.max(0, 0.8 - progress);
                        }
                    });
                    if (progress > 0.8) cloud.visible = false;
                });
                
                birds.forEach(bird => {
                    bird.visible = (progress < 0.6);
                });
                
                // Gradually reveal stars
                if (skybox.stars) {
                    skybox.stars.visible = progress > 0.7;
                    skybox.stars.material.opacity = (progress - 0.7) * 3.0; // Fade in stars
                }
                
                // Update sky color
                const skyColor = new THREE.Color();
                skyColor.lerpColors(skybox.dayColor, skybox.nightColor, progress);
                scene.background = skyColor;
            
            // Update fog for night
                if (progress > 0.5) {
                    if (!scene.fog) {
                        scene.fog = new THREE.Fog(new THREE.Color().lerpColors(skybox.dayColor, skybox.nightColor, progress), 10, 100);
            } else {
                        scene.fog.color.lerpColors(skybox.dayColor, skybox.nightColor, progress);
                        scene.fog.near = 10;
                        scene.fog.far = 100;
                    }
                }
                
                if (fadeProgress >= fadeDuration) {
                    clearInterval(fadeInterval);
                    
                    // Ensure final state is set correctly
                    sunLight.visible = false;
                    moonLight.visible = true;
                    skybox.sun.visible = false;
                    skybox.moon.visible = true;
                    skybox.stars.visible = true;
                    skybox.stars.material.opacity = 1.0;
                    sunrays.visible = false;
                    moonrays.visible = true;
                    scene.background = skybox.nightColor;
                    
                    // Hide clouds and birds
                    clouds.forEach(cloud => cloud.visible = false);
                    birds.forEach(bird => bird.visible = false);
                    
                    console.log("Night transition complete");
                }
            }, 16);
        }
        
        // Create star field
        function createStars() {
            const starCount = 1000;
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = new Float32Array(starCount * 3);
            const starColors = new Float32Array(starCount * 3);
            const starSizes = new Float32Array(starCount);
            
            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                
                // Create stars in a large sphere around the scene
                const radius = 500;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta) + 100; // Mostly above horizon
                starPositions[i3 + 2] = radius * Math.cos(phi);
                
                // Vary star colors slightly
                const brightness = 0.7 + Math.random() * 0.3;
                starColors[i3] = brightness;
                starColors[i3 + 1] = brightness;
                starColors[i3 + 2] = brightness + Math.random() * 0.1;
                
                // Vary star sizes
                starSizes[i] = Math.random() * 2 + 1;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
            
            const starMaterial = new THREE.PointsMaterial({
                size: 2,
                sizeAttenuation: false,
                vertexColors: true,
                transparent: true,
                opacity: 0
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            return stars;
        }
        
        // Function to create clouds
        function createCloud() {
            const cloudGroup = new THREE.Group();
            
            // Cloud is made of multiple spheres
            const sphereCount = 8 + Math.floor(Math.random() * 6);
            const cloudColor = 0xffffff;
            
            for (let i = 0; i < sphereCount; i++) {
                const sphereSize = 5 + Math.random() * 10;
                const sphereGeometry = new THREE.SphereGeometry(sphereSize, 8, 8);
                const sphereMaterial = new THREE.MeshStandardMaterial({
                    color: cloudColor,
                    emissive: cloudColor,
                    emissiveIntensity: 0.1,
                    transparent: true,
                    opacity: 0.8,
                    roughness: 1
                });
                
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                
                // Position spheres to form a cloud shape
                const radius = Math.random() * 12;
                const theta = Math.random() * Math.PI * 2;
                sphere.position.x = Math.cos(theta) * radius;
                sphere.position.z = Math.sin(theta) * radius;
                sphere.position.y = Math.random() * 5;
                
                cloudGroup.add(sphere);
            }
            
            return cloudGroup;
        }
        
        // Function to create a bird
        function createBird() {
            const birdGroup = new THREE.Group();
            
            // Bird body
            const bodyGeometry = new THREE.ConeGeometry(1, 4, 4);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            body.scale.set(0.5, 1, 0.5);
            birdGroup.add(body);
            
            // Bird wings
            const wingGeometry = new THREE.PlaneGeometry(5, 2);
            const wingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                side: THREE.DoubleSide
            });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(2.5, 0, 0);
            leftWing.name = 'leftWing';
            birdGroup.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(-2.5, 0, 0);
            rightWing.name = 'rightWing';
            birdGroup.add(rightWing);
            
            return birdGroup;
        }
        
        // Function to create sunrays
        function createSunrays() {
            // Create a sprite material with a radial gradient texture
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Create radial gradient
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 180, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 0, 0.2)');
            gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.7
            });
            
            const rays = new THREE.Sprite(material);
            rays.scale.set(200, 200, 1);
            
            return rays;
        }
        
        // Function to create moonrays
        function createMoonrays() {
            // Create a sprite material with a radial gradient texture
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Create radial gradient with blue/silver hues for moonlight
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(200, 220, 255, 0.6)');
            gradient.addColorStop(0.5, 'rgba(150, 180, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.5
            });
            
            const rays = new THREE.Sprite(material);
            rays.scale.set(150, 150, 1);
            
            return rays;
        }
        
        // Add the wave message function
        function showWaveMessage(text) {
            // Remove any existing message
            if (waveMessage && waveMessage.parentNode) {
                waveMessage.parentNode.removeChild(waveMessage);
            }
            
            // Create new message
            waveMessage = document.createElement('div');
            waveMessage.textContent = text;
            waveMessage.style.position = 'absolute';
            waveMessage.style.top = '10%';
            waveMessage.style.left = '50%';
            waveMessage.style.transform = 'translate(-50%, -50%)';
            waveMessage.style.color = 'orange';
            waveMessage.style.fontSize = '16px';
            waveMessage.style.fontWeight = 'bold';
            waveMessage.style.transition = 'opacity 1s';
            waveMessage.style.pointerEvents = 'none';
            waveMessage.style.textAlign = 'center';
            waveMessage.style.zIndex = '1000';
            
            document.body.appendChild(waveMessage);
            waveMessageTimer = 3; // Show message for 3 seconds
        }
        
        // Add robot laser updating system
        function updateRobotLasers(delta) {
            // Limit maximum lasers to prevent lag
            if (robotLasers.length > 20) {
                // Remove oldest lasers if we're over the limit
                while (robotLasers.length > 20) {
                    const oldLaser = robotLasers.shift();
                    // Clean up associated particles
                    if (oldLaser.userData.trailParticles) {
                        oldLaser.userData.trailParticles.forEach(particle => {
                            scene.remove(particle);
                        });
                    }
                    scene.remove(oldLaser);
                }
            }
            
            // Update lasers
            for (let i = robotLasers.length - 1; i >= 0; i--) {
                const laser = robotLasers[i];
                
                // Move laser forward
                laser.position.add(laser.userData.velocity.clone().multiplyScalar(delta * 30));
                
                // Update trail particles if they exist - limit updates for performance
                if (laser.userData.trailParticles && Math.random() < 0.7) {
                    laser.userData.trailParticles.forEach((particle, index) => {
                        // Follow behind laser at offset distance
                        const newPos = laser.position.clone().add(
                            laser.userData.velocity.clone().multiplyScalar(particle.userData.offset)
                        );
                        particle.position.copy(newPos);
                        
                        // Rotate particles for visual effect - reduce rotation calculations
                        if (Math.random() < 0.5) {
                            particle.rotation.x += particle.userData.rotationSpeed;
                            particle.rotation.y += particle.userData.rotationSpeed;
                        }
                        
                        // Fade out particles based on laser lifespan
                        particle.material.opacity = 0.7 * (1 - (laser.userData.distance / 30));
                    });
                }
                
                // Check if laser has reached maximum distance
                laser.userData.distance += delta * 30;
                if (laser.userData.distance > 30) {
                    // Remove trail particles
                    if (laser.userData.trailParticles) {
                        laser.userData.trailParticles.forEach(particle => {
                            scene.remove(particle);
                        });
                    }
                    
                    scene.remove(laser);
                    robotLasers.splice(i, 1);
                    continue;
                }
                
                // Check if laser hits player - optimize by not checking every frame
                if (Math.random() < 0.8 && laser.position.distanceTo(camera.position) < 1) {
                    // Player hit by laser
                    playerHealth -= 3; // Robot laser does 3 damage
                    document.getElementById('health').textContent = `Health: ${playerHealth}`;
                    
                    if (playerHealth <= 0) {
                        gameOver();
                    }
                    
                    // Remove trail particles
                    if (laser.userData.trailParticles) {
                        laser.userData.trailParticles.forEach(particle => {
                            scene.remove(particle);
                        });
                    }
                    
                    // Remove laser
                    scene.remove(laser);
                    robotLasers.splice(i, 1);
                    
                    // Add screen flash effect for player damage - bright blue for robot laser hit
                    const screenFlash = document.createElement('div');
                    screenFlash.style.position = 'absolute';
                    screenFlash.style.left = '0';
                    screenFlash.style.top = '0';
                    screenFlash.style.width = '100%';
                    screenFlash.style.height = '100%';
                    screenFlash.style.backgroundColor = 'rgba(0, 150, 255, 0.3)';
                    screenFlash.style.pointerEvents = 'none';
                    screenFlash.style.zIndex = '999';
                    screenFlash.style.transition = 'opacity 0.5s';
                    document.body.appendChild(screenFlash);
                    
                    // Remove the flash after a short delay
                    setTimeout(() => {
                        if (screenFlash.parentNode) {
                            screenFlash.style.opacity = 0;
                            setTimeout(() => {
                                if (screenFlash.parentNode) {
                                    screenFlash.parentNode.removeChild(screenFlash);
                                }
                            }, 500);
                        }
                    }, 100);
                }
            }
        }
        
        // Function to create a robot laser beam
        function shootRobotLaser(robot) {
            // Create laser geometry - thinner beam
            const laserGeometry = new THREE.CylinderGeometry(0.08, 0.08, 3, 8);
            laserGeometry.rotateX(Math.PI / 2); // Rotate to point forward
            
            // Create brighter blue material with glow effect
            const laserMaterial = new THREE.MeshBasicMaterial({
                color: 0x00aaff,
                emissive: 0x0088ff,
                emissiveIntensity: 3,
                transparent: true,
                opacity: 0.9
            });
            
            // Create laser mesh
            const laser = new THREE.Mesh(laserGeometry, laserMaterial);
            
            // Calculate the starting position at the robot's hand/arm
            const startPosition = robot.position.clone();
            const offset = new THREE.Vector3(0.8, -0.3, 0); // Offset for the "shooting arm"
            offset.applyQuaternion(robot.quaternion);
            startPosition.add(offset);
            laser.position.copy(startPosition);
            
            // Point directly at player from the actual starting position
            const direction = new THREE.Vector3();
            direction.subVectors(camera.position, startPosition).normalize(); // Use startPosition here
            
            // Add direction as velocity for movement
            laser.userData.velocity = direction;
            laser.userData.distance = 0;
            
            // Rotate laser mesh to face the calculated direction
            laser.lookAt(startPosition.clone().add(direction)); // Look along the velocity vector
            
            // Add to scene and tracking array
            scene.add(laser);
            robotLasers.push(laser);
            
            // Add laser light effect - brighter
            const laserLight = new THREE.PointLight(0x00aaff, 2, 8);
            laser.add(laserLight);
            
            // Add laser trail effects
            createLaserTrail(laser);
            
            // Add laser firing sound if audio is available
            if (audioContext) {
                const laserSound = audioContext.createOscillator();
                laserSound.type = 'sine';
                laserSound.frequency.setValueAtTime(880, audioContext.currentTime);
                
                const laserGain = audioContext.createGain();
                laserGain.gain.setValueAtTime(0.08, audioContext.currentTime); // Slightly louder
                laserGain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.5);
                
                laserSound.connect(laserGain);
                laserGain.connect(audioContext.destination);
                
                laserSound.start();
                laserSound.stop(audioContext.currentTime + 0.5);
            }
        }
        
        // Add new function to create laser trail particles
        function createLaserTrail(laser) {
            // Create small particles that follow behind the laser
            const numParticles = 5;
            
            for (let i = 0; i < numParticles; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.05, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.7
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Position slightly behind the laser
                particle.position.copy(laser.position);
                particle.position.add(laser.userData.velocity.clone().multiplyScalar(-0.5 * i));
                
                // Store reference to parent laser and offset
                particle.userData.laser = laser;
                particle.userData.offset = -0.5 * i;
                particle.userData.rotationSpeed = Math.random() * 0.2;
                
                scene.add(particle);
                
                // Add particle to laser's userData for tracking
                if (!laser.userData.trailParticles) {
                    laser.userData.trailParticles = [];
                }
                laser.userData.trailParticles.push(particle);
            }
        }
        
        // Function to spawn a robot
        function spawnRobot() {
            // Create robot group
            const robotBody = new THREE.Group();
            
            // Create the robot model
            // Main body/head - white sphere on top, black sphere on bottom
            const topSphereGeometry = new THREE.SphereGeometry(1, 16, 16);
            const topSphereMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                roughness: 0.3,
                metalness: 0.7
            });
            const topSphere = new THREE.Mesh(topSphereGeometry, topSphereMaterial);
            topSphere.position.y = 0.5;
            robotBody.add(topSphere);
            
            // Bottom sphere (black)
            const bottomSphereGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const bottomSphereMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                roughness: 0.2,
                metalness: 0.8
            });
            const bottomSphere = new THREE.Mesh(bottomSphereGeometry, bottomSphereMaterial);
            bottomSphere.position.y = -0.3;
            robotBody.add(bottomSphere);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                roughness: 0.5,
                metalness: 0.5
            });
            
            // Left arm
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.rotation.z = Math.PI / 4; // 45 degrees
            leftArm.position.x = 1;
            leftArm.position.y = 0;
            robotBody.add(leftArm);
            
            // Right arm
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.rotation.z = -Math.PI / 4; // -45 degrees
            rightArm.position.x = -1;
            rightArm.position.y = 0;
            robotBody.add(rightArm);
            
            // Hands/manipulators
            const handGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const handMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                roughness: 0.3,
                metalness: 0.7
            });
            
            // Left hand
            const leftHand = new THREE.Mesh(handGeometry, handMaterial);
            leftHand.position.y = -0.7;
            leftHand.position.x = 0.2;
            leftArm.add(leftHand);
            
            // Right hand
            const rightHand = new THREE.Mesh(handGeometry, handMaterial);
            rightHand.position.y = -0.7;
            rightHand.position.x = -0.2;
            rightArm.add(rightHand);
            
            // Antenna
            const antennaGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
            const antennaMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                roughness: 0.5,
                metalness: 0.5
            });
            const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            antenna.position.y = 1.2;
            robotBody.add(antenna);
            
            // Antenna tip (red)
            const antennaTipGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const antennaTipMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 1
            });
            const antennaTip = new THREE.Mesh(antennaTipGeometry, antennaTipMaterial);
            antennaTip.position.y = 0.3;
            antenna.add(antennaTip);
            
            // Position robot at a random location around the player
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 20 + 40; // Further away than zombies
            
            robotBody.position.x = Math.cos(angle) * distance;
            robotBody.position.z = Math.sin(angle) * distance;
            robotBody.position.y = 6; // Hover at 6 units above ground as requested
            
            // Add properties for game logic
            robotBody.userData.health = 4; // Set to exactly 4 hits
            robotBody.userData.maxHealth = 4; // Store max health value
            robotBody.userData.speed = Math.random() * 0.01 + 0.008; // Faster than before
            robotBody.userData.isRobot = true;
            robotBody.userData.shootCooldown = 3; // Exactly 3 seconds between shots
            robotBody.userData.hitsTaken = 0;
            robotBody.userData.hoverHeight = 6; // Hover at 6 units
            robotBody.userData.hoverSpeed = Math.random() * 0.8 + 0.7; // Faster hover
            robotBody.userData.hoverPhase = Math.random() * Math.PI * 2;
            robotBody.userData.flyingPathRadius = Math.random() * 5 + 10; // Radius for circular flying pattern
            robotBody.userData.flyingSpeed = Math.random() * 0.005 + 0.003; // Flying speed
            robotBody.userData.flyingPhase = Math.random() * Math.PI * 2; // Random starting phase
            robotBody.name = "robot";
            
            // Make sure all child objects reference back to the parent robot
            robotBody.traverse(child => {
                child.userData.robotRoot = robotBody;
            });
            
            console.log(`Created robot with ${robotBody.userData.health} health`);
            
            scene.add(robotBody);
            robots.push(robotBody);
            zombies.push(robotBody); // Add to zombies array for consistent processing
        }
        
        // Add the playGunShotSound function that's referenced but not defined
        function playGunShotSound() {
            if (!gunShotSound) return;
            
            try {
                if (audioContext) {
                    // Web Audio API implementation
                    const source = audioContext.createBufferSource();
                    source.buffer = gunShotSound;
                    
                    // Create gain node for volume control
                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = 0.3; // Reduce volume to 30%
                    
                    // Connect source -> gain -> destination
                    source.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    source.start(0);
                } else if (gunShotSound instanceof Audio) {
                    // HTML5 Audio fallback
                    gunShotSound.currentTime = 0;
                    gunShotSound.volume = 0.3; // Reduce volume to 30%
                    gunShotSound.play().catch(error => {
                        console.error('Error playing gun sound:', error);
                    });
                }
            } catch (e) {
                console.error('Error playing gunshot sound:', e);
            }
        }
        
        // Function to switch weapons
        function switchWeapon(weaponType) {
            if (currentWeapon === weaponType) return;
            
            currentWeapon = weaponType;
            showWeaponMessage(`${weapons[weaponType].name} equipped`);
            
            // Update ammo counts
            updateAmmoDisplay();
        }
        
        // Add ammo display
        function updateAmmoDisplay() {
            const weapon = weapons[currentWeapon];
            let ammoText = '';
            
            if (weapon.infiniteAmmo) {
                ammoText = '∞';
            } else {
                if (currentWeapon === 'shotgun') {
                    ammoText = shotgunAmmo;
                } else if (currentWeapon === 'sniper') {
                    ammoText = sniperAmmo;
                } else if (currentWeapon === 'machineGun') {
                    ammoText = machineGunAmmo;
                }
            }
            
            // Update display if an ammo element exists
            const ammoDisplay = document.getElementById('ammo');
            if (ammoDisplay) {
                ammoDisplay.textContent = `Ammo: ${ammoText}`;
            }
        }
        
        // Add a function to show weapon message
        function showWeaponMessage(text) {
            // Remove any existing message
            if (weaponMessage && weaponMessage.parentNode) {
                weaponMessage.parentNode.removeChild(weaponMessage);
            }
            
            // Create new message
            weaponMessage = document.createElement('div');
            weaponMessage.textContent = text;
            weaponMessage.style.position = 'absolute';
            weaponMessage.style.bottom = '10%';
            weaponMessage.style.left = '50%';
            weaponMessage.style.transform = 'translate(-50%, 0)';
            weaponMessage.style.color = 'white';
            weaponMessage.style.fontSize = '16px';
            weaponMessage.style.fontWeight = 'bold';
            weaponMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            weaponMessage.style.padding = '5px 15px';
            weaponMessage.style.borderRadius = '5px';
            weaponMessage.style.transition = 'opacity 1s';
            weaponMessage.style.pointerEvents = 'none';
            weaponMessage.style.textAlign = 'center';
            weaponMessage.style.zIndex = '1000';
            
            document.body.appendChild(weaponMessage);
            weaponMessageTimer = 3; // Show message for 3 seconds
        }
        
        // Add crawling zombie animation to animate function
        // In the animate function, after the wave transition checks
        // Check for wave transitions
        if (gameTime >= 400 && currentWave === 3 && !isBossFight) {
            currentWave = 4;
            
            // Keep other enemies present during boss fight - don't clear them
            
            // Trigger boss fight
            showWaveMessage("BOSS FIGHT");
            waveMessageTimer = 3; // Set timer to 3 seconds
            isBossFight = true;
            spawnBossZombie();
        } else if (gameTime >= 240 && currentWave === 2) {
            currentWave = 3;
            showWaveMessage("WAVE 3");
            waveMessageTimer = 3; // Set timer to 3 seconds
            
            // Spawn robot enemies to announce wave 3
            for (let i = 0; i < 2; i++) {
                spawnRobot();
            }
        } else if (gameTime >= 180 && currentWave === 1) {
            currentWave = 2;
            showWaveMessage("WAVE 2");
            waveMessageTimer = 3; // Set timer to 3 seconds
            
            // Spawn a few tough zombies to announce wave 2
            for (let i = 0; i < 3; i++) {
                spawnZombie(true); // Spawn tough zombies
            }
        }
        
        // Spawn new zombies occasionally if there are fewer than the limit and not in boss fight
        const maxEnemies = currentWave >= 3 ? 15 : 10;
        
        if (zombies.length < maxEnemies && Math.random() < 0.005) {
            if (currentWave === 1) {
                // Wave 1: Only small zombies
                spawnZombie(false);
            } else if (currentWave === 2) {
                // Wave 2: Mix of small and tough zombies
                const spawnToughZombie = Math.random() < 0.4; // 40% chance of tough zombie
                spawnZombie(spawnToughZombie);
            } else if (currentWave === 3) {
                // Wave 3: Mix of all enemy types
                const rand = Math.random();
                if (rand < 0.3) {
                    // 30% chance of a robot
                    spawnRobot();
                } else if (rand < 0.6) {
                    // 30% chance of a tough zombie
                    spawnZombie(true);
                } else {
                    // 40% chance of a small zombie
                    spawnZombie(false);
                }
            }
        }
        
        // Add code to update crawling zombies in the animate function, after the robot update section
        // Update crawling zombies
        zombies.forEach(zombie => {
            if (zombie.userData.isCrawler) {
                // Crawlers move slower but have a unique animation
                zombie.userData.crawlPhase += 0.1;
                
                // Make crawler face player
                const zombieToPlayer = new THREE.Vector3(
                    camera.position.x - zombie.position.x,
                    0,
                    camera.position.z - zombie.position.z
                ).normalize();
                
                zombie.lookAt(camera.position.x, zombie.position.y, camera.position.z);
                
                // Move crawler toward player (slower than regular zombies)
                zombie.position.x += zombieToPlayer.x * zombie.userData.speed * delta * 60;
                zombie.position.z += zombieToPlayer.z * zombie.userData.speed * delta * 60;
                
                // Crawling animation - keep position low to the ground
                zombie.position.y = 0.2 + Math.sin(zombie.userData.crawlPhase * 0.5) * 0.1;
                
                // Animate arms dragging motion
                if (zombie.children[0]) {
                    const armLeft = zombie.children[0].children.find(c => c.name === 'armLeft');
                    const armRight = zombie.children[0].children.find(c => c.name === 'armRight');
                    
                    if (armLeft) {
                        armLeft.rotation.x = Math.PI / 3 + Math.sin(zombie.userData.crawlPhase) * 0.4;
                    }
                    
                    if (armRight) {
                        armRight.rotation.x = Math.PI / 3 + Math.sin(zombie.userData.crawlPhase + Math.PI) * 0.4;
                    }
                    
                    // If it has legs, make them drag behind
                    const legLeft = zombie.children[0].children.find(c => c.name === 'legLeft');
                    const legRight = zombie.children[0].children.find(c => c.name === 'legRight');
                    
                    if (legLeft) {
                        legLeft.rotation.x = -Math.PI / 6;
                    }
                    
                    if (legRight) {
                        legRight.rotation.x = -Math.PI / 6;
                    }
                }
            }
        });
        
        
        
        // Add function to spawn crawling zombies
        function spawnCrawlingZombie() {
            let zombieBody = new THREE.Group();
            
            // Create voxel-style crawling zombie
            function createCrawlingZombie() {
                const voxelGroup = new THREE.Group();
                const voxelSize = 0.1; // Similar to small zombies
                
                // Define base colors
                const bodyColor = 0x447755; // Darker green for crawlers
                const clothingColor = 0x553311; // Tattered clothing
                const eyeColor = 0xff3300; // Red eyes
                
                // Create head
                const headSize = 0.5;
                const headVoxelCount = Math.floor(headSize / voxelSize);
                const headGroup = new THREE.Group();
                
                for (let x = 0; x < headVoxelCount; x++) {
                    for (let y = 0; y < headVoxelCount; y++) {
                        for (let z = 0; z < headVoxelCount; z++) {
                            // Skip some voxels for damaged/missing chunks effect (more damaged than regular zombies)
                            if (Math.random() < 0.4) continue;
                            
                            const voxel = new THREE.Mesh(
                                new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize),
                                new THREE.MeshStandardMaterial({ 
                                    color: bodyColor,
                                    roughness: 0.7,
                                    metalness: 0.1
                                })
                            );
                            
                            voxel.position.set(
                                (x - headVoxelCount/2) * voxelSize,
                                (y - headVoxelCount/2) * voxelSize,
                                (z - headVoxelCount/2) * voxelSize
                            );
                            
                            headGroup.add(voxel);
                        }
                    }
                }
                
                // Add glowing eyes
                const eyeSize = voxelSize * 1.2;
                const leftEye = new THREE.Mesh(
                    new THREE.BoxGeometry(eyeSize, eyeSize, eyeSize * 0.6),
                    new THREE.MeshBasicMaterial({ 
                        color: eyeColor,
                        emissive: eyeColor,
                        emissiveIntensity: 1.0
                    })
                );
                
                const rightEye = leftEye.clone();
                
                leftEye.position.set(-headSize * 0.3, headSize * 0.1, headSize * 0.5);
                rightEye.position.set(headSize * 0.3, headSize * 0.1, headSize * 0.5);
                
                headGroup.add(leftEye);
                headGroup.add(rightEye);
                headGroup.position.y = 0.3; // Lower to the ground for crawling
                headGroup.rotation.x = Math.PI / 6; // Slightly tilted up to look ahead while crawling
                headGroup.name = 'head';
                voxelGroup.add(headGroup);
                
                // Create body - flatter for crawling
                const torsoWidth = 0.6;
                const torsoHeight = 0.3; // Flatter for crawler
                const torsoDepth = 0.3;
                const torsoGroup = new THREE.Group();
                
                const torsoWCount = Math.floor(torsoWidth / voxelSize);
                const torsoHCount = Math.floor(torsoHeight / voxelSize);
                const torsoDCount = Math.floor(torsoDepth / voxelSize);
                
                for (let x = 0; x < torsoWCount; x++) {
                    for (let y = 0; y < torsoHCount; y++) {
                        for (let z = 0; z < torsoDCount; z++) {
                            // Skip some voxels
                            if (Math.random() < 0.3) continue;
                            
                            const voxel = new THREE.Mesh(
                                new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize),
                                new THREE.MeshStandardMaterial({ 
                                    color: y < torsoHCount/2 ? clothingColor : bodyColor,
                                    roughness: 0.8,
                                    metalness: 0.1
                                })
                            );
                            
                            voxel.position.set(
                                (x - torsoWCount/2) * voxelSize,
                                (y - torsoHCount/2) * voxelSize,
                                (z - torsoDCount/2) * voxelSize
                            );
                            
                            torsoGroup.add(voxel);
                        }
                    }
                }
                
                // Position torso
                torsoGroup.position.y = 0.1; // Very low to the ground
                voxelGroup.add(torsoGroup);
                
                // Create arms - extended for crawling
                const armLength = 0.6;
                const armWidth = 0.15;
                
                for (let side = -1; side <= 1; side += 2) {
                    if (side === 0) continue;
                    
                    const armGroup = new THREE.Group();
                    const armWCount = Math.floor(armWidth / voxelSize);
                    const armLCount = Math.floor(armLength / voxelSize);
                    
                    for (let x = 0; x < armWCount; x++) {
                        for (let y = 0; y < armLCount; y++) {
                            for (let z = 0; z < armWCount; z++) {
                                // Skip some voxels for damaged effect
                                if (Math.random() < 0.3) continue;
                                
                                const voxel = new THREE.Mesh(
                                    new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize),
                                    new THREE.MeshStandardMaterial({ 
                                        color: bodyColor,
                                        roughness: 0.8,
                                        metalness: 0.1
                                    })
                                );
                                
                                voxel.position.set(
                                    (x - armWCount / 2 + 0.5) * voxelSize,
                                    (y - armLCount / 2 + 0.5) * voxelSize,
                                    (z - armDCount / 2 + 0.5) * voxelSize
                                );
                                armGroup.add(voxel);
                            }
                        }
                    }
                    
                    // Position arm extended forward for crawling
                    armGroup.position.set(side * armWidth * 1.5, 0.2, armLength * 0.4);
                    armGroup.rotation.x = Math.PI / 3; // Arms angled to drag along ground
                    armGroup.name = side > 0 ? 'armRight' : 'armLeft';
                    voxelGroup.add(armGroup);
                }
                
                // Create legs (dragging behind)
                const legLength = 0.6;
                const legWidth = 0.15;
                
                for (let side = -1; side <= 1; side += 2) {
                    if (side === 0) continue;
                    
                    const legGroup = new THREE.Group();
                    const legWCount = Math.floor(legWidth / voxelSize);
                    const legLCount = Math.floor(legLength / voxelSize);
                    
                    for (let x = 0; x < legWCount; x++) {
                        for (let y = 0; y < legLCount; y++) {
                            for (let z = 0; z < legWCount; z++) {
                                // Skip some voxels - damaged/missing chunks
                                if (Math.random() < 0.3) continue;
                                
                                const voxel = new THREE.Mesh(
                                    new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize),
                                    new THREE.MeshStandardMaterial({ 
                                        color: 0x1a1a2e, // Dark pants
                                        roughness: 0.8,
                                        metalness: 0.1
                                    })
                                );
                                
                                voxel.position.set(
                                    (x - legWCount/2) * voxelSize,
                                    (y - legLCount/2) * voxelSize,
                                    (z - legWCount/2) * voxelSize
                                );
                                
                                legGroup.add(voxel);
                            }
                        }
                    }
                    
                    // Position legs dragging behind
                    legGroup.position.set(side * legWidth * 1.2, 0.1, -legLength * 0.3);
                    legGroup.rotation.x = -Math.PI / 6; // Legs angled backward
                    legGroup.name = side > 0 ? 'legRight' : 'legLeft';
                    voxelGroup.add(legGroup);
                }
                
                return voxelGroup;
            }
            
            // Create the crawler zombie
            const zombie = createCrawlingZombie();
            zombieBody.add(zombie);
            
            // Position crawler at a random location around the player
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 20 + 30; // Between 30 and 50 units away
            
            zombieBody.position.x = Math.cos(angle) * distance;
            zombieBody.position.z = Math.sin(angle) * distance;
            zombieBody.position.y = 0.2; // Low to the ground
            
            // Add properties for game logic
            zombieBody.userData.health = 75; // 3 hits at 25 damage
            zombieBody.userData.speed = Math.random() * 0.015 + 0.007; // Between regular and tough zombies
            zombieBody.userData.isCrawler = true;
            zombieBody.userData.hitsTaken = 0;
            zombieBody.userData.crawlPhase = Math.random() * Math.PI * 2; // For crawling animation
            zombieBody.name = "crawler";
            
            // Make sure all child objects reference back to the parent zombie
            zombieBody.traverse(child => {
                child.userData.zombieRoot = zombieBody;
            });
            
            console.log(`Created Crawling zombie with ${zombieBody.userData.health} health`);
            
            scene.add(zombieBody);
            zombies.push(zombieBody);
        }
        
        // Update the wave trigger when a zombie/robot is killed in the shoot function
        // Inside processHits function where it spawns a new enemy after killing one:
        setTimeout(() => {
            if (currentWave === 3 && !isBossFight) {
                const rand = Math.random();
                if (rand < 0.3) {
                    spawnRobot();
                } else if (rand < 0.6) {
                    spawnZombie(true);
                } else {
                    spawnZombie(false);
                }
            }
        }, 1000);
        
        // Start the game - don't call init() directly, wait for user to click startButton
        // init();

        // Instead, make init() create the scene but not start immediately
        document.addEventListener('DOMContentLoaded', function() {
            // Call init but don't start animation loop yet
        init();
            
            // Debug log that event listeners are set up
            console.log('Game initialized and waiting for start button click');
        });
        
        // Function to spawn a powerup
        function spawnPowerup(type, position) {
            console.log(`Spawning powerup of type: ${type}`);
            
            let powerupGeometry, powerupMaterial, powerupSize, powerupMesh;
            
            switch (type) {
                case 'shotgun':
                    // Detailed shotgun shell model based on the provided image
                    powerupSize = 0.52; // Adjusted overall size (0.40 + 0.12)
                    const shellGroup = new THREE.Group();
                    const shellRadius = 0.12; // Reduced radius from 0.15
                    const mainBodyHeight = 0.40; // Reduced height from 0.45
                    const baseHeight = 0.12; // Reduced height from 0.15
                    
                    // Main Body (Red)
                    const shellBodyGeometry = new THREE.CylinderGeometry(shellRadius, shellRadius, mainBodyHeight, 16);
                    // Match the red color from the image, slightly darker tone
                    const shellBodyMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xB83333, // Darker red like the image
                        roughness: 0.6,
                        metalness: 0.2
                    });
                    const shellBodyMesh = new THREE.Mesh(shellBodyGeometry, shellBodyMaterial);
                    // Position the red body part (relative to the group's center)
                    shellBodyMesh.position.y = baseHeight / 2;
                    shellBodyMesh.castShadow = true;
                    shellGroup.add(shellBodyMesh);
                    
                    // Base (Brass/Gold)
                    const shellBaseGeometry = new THREE.CylinderGeometry(shellRadius, shellRadius, baseHeight, 16);
                    // Match the brass color from the image
                    const shellBaseMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xD4AF37, // Brass/Gold color like the image
                        roughness: 0.4, 
                        metalness: 0.8 
                    });
                    const shellBaseMesh = new THREE.Mesh(shellBaseGeometry, shellBaseMaterial);
                    // Position the base below the red body (relative to the group's center)
                    shellBaseMesh.position.y = -mainBodyHeight / 2;
                    shellBaseMesh.castShadow = true;
                    shellGroup.add(shellBaseMesh);
                    
                    powerupMesh = shellGroup;
                    // No need to rotate this model upright, it's built vertically
                    break;
                case 'sniper':
                    // Box with 3 bullets for sniper ammo
                    powerupSize = 0.6; // Slightly larger overall size
                    const sniperGroup = new THREE.Group();
                    
                    // Box/Container (dark grey)
                    const boxWidth = 0.6;
                    const boxHeight = 0.2;
                    const boxDepth = 0.4;
                    const boxGeometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
                    const boxMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7 });
                    const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
                    boxMesh.position.y = boxHeight / 2;
                    sniperGroup.add(boxMesh);
                    
                    // Bullets (gold)
                    const bulletRadius = 0.05;
                    const bulletHeight = 0.3;
                    const bulletGeometry = new THREE.CylinderGeometry(bulletRadius, bulletRadius * 0.7, bulletHeight, 8);
                    const bulletMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.4, metalness: 0.8 });
                    
                    // Create and position 3 bullets inside the box
                    for (let i = -1; i <= 1; i++) {
                        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                        bullet.position.set(
                            i * (boxWidth / 4), // Spaced out along x
                            boxHeight / 2 + bulletHeight / 2 - 0.02, // Positioned inside, slightly above bottom
                            0 // Centered in depth
                        );
                        bullet.rotation.x = Math.PI / 2; // Lay bullets flat (optional, could stand them up)
                        sniperGroup.add(bullet);
                    }
                    powerupMesh = sniperGroup;
                    break;
                case 'grenade':
                    // Grenade model like the image
                    powerupSize = 0.5; // Overall size
                    const grenadeGroup = new THREE.Group();
                    
                    // Body (segmented green sphere)
                    // Use Icosahedron for a more blocky/faceted look
                    const bodyGeometry = new THREE.IcosahedronGeometry(0.3 * powerupSize, 1); // Detail level 1 for some facets
                    const bodyMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x2f4f2f, // Darker green
                        flatShading: true, // Gives a segmented look
                        roughness: 0.7 
                    });
                    const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    bodyMesh.position.y = 0.3 * powerupSize;
                    grenadeGroup.add(bodyMesh);
                    
                    // Top Mechanism (grey cylinder + lever + pin)
                    const topMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.5, metalness: 0.7 });
                    
                    // Cylinder base
                    const topBaseGeometry = new THREE.CylinderGeometry(0.1 * powerupSize, 0.12 * powerupSize, 0.2 * powerupSize, 8);
                    const topBaseMesh = new THREE.Mesh(topBaseGeometry, topMaterial);
                    topBaseMesh.position.y = 0.6 * powerupSize; // Position on top of the body
                    grenadeGroup.add(topBaseMesh);
                    
                    // Lever (flat box)
                    const leverGeometry = new THREE.BoxGeometry(0.05 * powerupSize, 0.3 * powerupSize, 0.15 * powerupSize);
                    const leverMesh = new THREE.Mesh(leverGeometry, topMaterial);
                    leverMesh.position.set(0.08 * powerupSize, 0.7 * powerupSize, 0);
                    leverMesh.rotation.z = Math.PI / 6; // Angle the lever slightly
                    grenadeGroup.add(leverMesh);
                    
                    // Pin Ring (torus)
                    const pinGeometry = new THREE.TorusGeometry(0.1 * powerupSize, 0.03 * powerupSize, 6, 12);
                    const pinMesh = new THREE.Mesh(pinGeometry, topMaterial);
                    pinMesh.position.set(0.18 * powerupSize, 0.75 * powerupSize, 0); // Position near the lever top
                    pinMesh.rotation.y = Math.PI / 2;
                    grenadeGroup.add(pinMesh);
                    
                    powerupMesh = grenadeGroup;
                    break;
                default:
                    console.error("Invalid powerup type requested:", type);
                    return; // Don't spawn if type is invalid
            }
            
            if (!powerupMesh) {
                console.error(`Failed to create powerup mesh for type: ${type}`);
                return;
            }

            // Common properties for the powerup mesh
            powerupMesh.castShadow = true;
            
            // Spawn at the provided position (where the enemy died)
            const spawnPos = position.clone();
            
            // Make all powerups start at same height from ground for consistency
            spawnPos.y = 0.5; // Fixed height for all powerups
            
            powerupMesh.position.copy(spawnPos);
            
            // Add a light to make powerups more visible
            const powerupLight = new THREE.PointLight(0xffffff, 1, 2);
            powerupLight.position.set(0, 0, 0);
            powerupMesh.add(powerupLight);
            
            powerupMesh.userData = {
                type: type,
                size: powerupSize,
                floatPhase: Math.random() * Math.PI * 2, // For floating animation
                rotationSpeed: Math.random() * 0.03 + 0.02 // Faster rotation for better visibility
            };
            
            scene.add(powerupMesh);
            activePowerups.push(powerupMesh);
            console.log(`Spawned powerup: ${type} at x:${spawnPos.x.toFixed(1)}, z:${spawnPos.z.toFixed(1)}`);
        }
        
        // Function to update powerup animations (floating/rotating)
        function updateActivePowerups(delta) {
            for (let i = activePowerups.length - 1; i >= 0; i--) {
                const powerup = activePowerups[i];
                
                // Enhanced floating animation - float higher
                powerup.userData.floatPhase += delta * 2;
                powerup.position.y = 0.5 + Math.sin(powerup.userData.floatPhase) * 0.3;
                
                // Enhanced rotation animation - spin faster and in multiple directions
                powerup.rotation.y += powerup.userData.rotationSpeed * delta * 60;
                
                // Make shotgun powerups more noticeably red by pulsing intensity
                if (powerup.userData.type === 'shotgun' && powerup.material) {
                    powerup.material.emissiveIntensity = 0.3 + Math.abs(Math.sin(powerup.userData.floatPhase * 2)) * 0.7;
                }
                
                // Increased collection radius - easier to pick up
                if (powerup.position.distanceTo(camera.position) < 2) {
                    collectPowerup(powerup);
                    scene.remove(powerup);
                    activePowerups.splice(i, 1);
                }
            }
        }
        
        // Function to handle powerup collection
        function collectPowerup(powerup) {
            const type = powerup.userData.type;
            console.log(`Collected powerup: ${type}`);
            
            switch (type) {
                case 'shotgun':
                    const prevAmmo = shotgunAmmo;
                    shotgunAmmo += 10;
                    console.log(`Shotgun ammo increased from ${prevAmmo} to ${shotgunAmmo}`);
                    showWeaponMessage("+10 Shotgun Ammo");
                    break;
                case 'sniper':
                    sniperAmmo += 15;
                    showWeaponMessage("+15 Sniper Ammo");
                    break;
                case 'grenade':
                    grenadeCount += 1;
                    showWeaponMessage("+1 Grenade");
                    updateGrenadeDisplay();
                    break;
            }
            
            // Update ammo display if needed (for shotgun/sniper)
            if (type !== 'grenade') {
                updateAmmoDisplay();
                // Double check the ammo count is correctly updated in the DOM
                console.log(`Current weapon: ${currentWeapon}, Shotgun ammo: ${shotgunAmmo}, Sniper ammo: ${sniperAmmo}`);
            }
        }
        
        // Function to update the grenade HUD
        function updateGrenadeDisplay() {
            const grenadeDisplay = document.getElementById('grenadeCount');
            if (grenadeDisplay) {
                grenadeDisplay.textContent = `Grenades: ${grenadeCount}`;
            }
        }
        
        // Function to throw a grenade
        function throwGrenade() {
            if (grenadeCount <= 0) {
                showWeaponMessage("Out of grenades!");
                return;
            }
            
            grenadeCount--;
            updateGrenadeDisplay();
            
            // Create grenade object (using simple sphere for now)
            const grenadeSize = 0.5; // Used for potential future detailed model
            // const grenadeGroup = createGrenadeModel(grenadeSize); // REMOVED - Assuming this function is missing/broken
            
            // Use simple sphere for physics and visuals
            const grenadeGeometry = new THREE.SphereGeometry(0.3, 8, 8); 
            const grenadeMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.6, visible: true }); // Make sphere visible
            const grenade = new THREE.Mesh(grenadeGeometry, grenadeMaterial); 
            grenade.castShadow = true;

            
            // Position grenade slightly in front of the camera center
            const startPosition = new THREE.Vector3();
            camera.getWorldPosition(startPosition);
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction); // Get camera's forward direction
            startPosition.add(direction.multiplyScalar(1.0)); // Start 1 unit in front
            grenade.position.copy(startPosition);
            
            // Calculate initial velocity based precisely on camera direction + upward arc
            const throwForce = 18; // Slightly increased force for better arc
            const upwardForce = 6; 
            const velocity = direction.clone().multiplyScalar(throwForce); // Base velocity in aiming direction
            velocity.y += upwardForce; // Add upward component for the arc
            
            grenade.userData = {
                velocity: velocity,
                life: 3, // 3 second fuse
                gravity: -9.8, // Simple gravity
                rotationAxis: new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize(),
                rotationSpeed: Math.random() * 5 + 2 // Random rotation speed
            };
            
            scene.add(grenade);
            activeGrenades.push(grenade);
            
            // Play throw sound (optional)
            // playThrowSound();
        }
        
        // Function to update active grenades (movement, physics, explosion)
        function updateActiveGrenades(delta) {
            for (let i = activeGrenades.length - 1; i >= 0; i--) {
                const grenade = activeGrenades[i];
                
                // Apply gravity
                grenade.userData.velocity.y += grenade.userData.gravity * delta;
                
                // Update position
                grenade.position.add(grenade.userData.velocity.clone().multiplyScalar(delta));
                
                // Apply rotation
                grenade.rotateOnAxis(grenade.userData.rotationAxis, grenade.userData.rotationSpeed * delta);

                // Simple ground collision
                if (grenade.position.y <= 0.3) {
                    grenade.position.y = 0.3;
                    // Bounce effect (reduce velocity)
                    grenade.userData.velocity.y *= -0.5; // Lose half vertical velocity on bounce
                    grenade.userData.velocity.x *= 0.8; // Friction
                    grenade.userData.velocity.z *= 0.8; // Friction
                }
                
                // Update fuse timer
                grenade.userData.life -= delta;
                
                // Explode when timer runs out
                if (grenade.userData.life <= 0) {
                    explodeGrenade(grenade.position);
                    scene.remove(grenade);
                    activeGrenades.splice(i, 1);
                }
            }
        }
        
        // Function to handle grenade explosion
        function explodeGrenade(position) {
            console.log("Grenade exploded!");
            
            // Explosion visual effect (e.g., particles)
            createExplosionEffect(position);
            
            // Play explosion sound (optional)
            // playExplosionSound();
            if (audioContext && grenadeSound) {
                try {
                    const source = audioContext.createBufferSource();
                    source.buffer = grenadeSound;
                    source.connect(audioContext.destination);
                    source.start(0);
                    console.log("Playing grenade explosion sound.");
                } catch (e) {
                    console.error("Error playing grenade sound:", e);
                }
            }
            
            // Damage enemies within radius
            const explosionRadius = 12; // Increased from 8
            const explosionDamage = 150; // High damage
            
            zombies.forEach(enemy => {
                if (enemy.position.distanceTo(position) < explosionRadius) {
                    // Apply damage (bypassing hit counter for robots)
                    let damageToApply = explosionDamage;
                    
                    if (enemy.userData.isRobot) {
                        // Grenades heavily damage robots, ignore 4-hit rule
                        enemy.userData.health -= damageToApply;
                        console.log(`Robot caught in explosion! Health: ${enemy.userData.health}`);
                    } else {
                        enemy.userData.health -= damageToApply;
                        console.log(`Zombie caught in explosion! Health: ${enemy.userData.health}`);
                    }
                    
                    // Add hit flash effect
                    addHitFlashEffect(enemy);
                    
                    // Check if destroyed immediately
                    if (enemy.userData.health <= 0) {
                        console.log("Enemy destroyed by grenade!");
                        scene.remove(enemy);
                        // Remove from appropriate arrays (zombies, robots)
                        if (enemy.userData.isRobot) {
                            robots = robots.filter(r => r !== enemy);
                        }
                        zombies = zombies.filter(z => z !== enemy);
                        
                        // Update score based on enemy type
                        let scorePoints = 100; // Default
                        if (enemy.userData.isToughZombie) scorePoints = 500;
                        else if (enemy.userData.isRobot) scorePoints = 250;
                        else if (enemy.userData.isCrawler) scorePoints = 200;
                        score += scorePoints;
                        document.getElementById('score').textContent = `Score: ${score}`; 
                    }
                }
            });
        }
        
        // Function to create explosion particle effect
        function createExplosionEffect(position) {
            const particleCount = 80; // Increased particle count
            const particleGeometry = new THREE.SphereGeometry(0.15, 8, 8); // Slightly larger particles
            
            for (let i = 0; i < particleCount; i++) {
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? (Math.random() > 0.5 ? 0xff4500 : 0xff8800) : 0xffcc00, // Orange/Red/Yellow mix
                    transparent: true,
                    opacity: 0.95 // Slightly less transparent initially
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                
                // Random velocity outwards - slightly faster
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2 + 1, // Bias upwards
                    (Math.random() - 0.5) * 2
                ).normalize().multiplyScalar(Math.random() * 12 + 6); // Increased speed range
                
                particle.userData = {
                    velocity: velocity,
                    life: 0.6 + Math.random() * 0.6, // Slightly longer lifespan (0.6 - 1.2s)
                    gravity: -12 // Slightly stronger gravity for faster fall
                };
                
                scene.add(particle);
                
                // Animate the particle
                const animateParticle = (particle) => {
                    const delta = 0.016; // Assume ~60fps for simple particle update
                    particle.userData.velocity.y += particle.userData.gravity * delta;
                    particle.position.add(particle.userData.velocity.clone().multiplyScalar(delta));
                    particle.userData.life -= delta;
                    particle.material.opacity = Math.max(0, particle.userData.life * 2); // Fade out
                    
                    if (particle.userData.life > 0) {
                        requestAnimationFrame(() => animateParticle(particle));
                    } else {
                        scene.remove(particle);
                    }
                };
                animateParticle(particle);
            }
        }

        // Function to create a watchtower
        function createWatchTower() {
            const towerGroup = new THREE.Group();
            const woodColor = 0xab855a; // Light brown wood
            const supportColor = 0x556B2F; // Dark olive green
            const concreteColor = 0xa9a9a9; // Dark grey
            const hutColor = 0x6B8E23; // Olive drab green for hut

            const plankThickness = 0.2;
            const railingHeight = 0.8;
            const supportRadius = 0.3;
            const platformWidth = 6;
            const platformDepth = 6;
            const platformHeight1 = 4; // Height of the lower platform
            const platformHeight2 = 8; // Height of the upper platform
            const hutSize = 3;
            const hutHeight = 2.5;

            const woodMaterial = new THREE.MeshStandardMaterial({ color: woodColor, roughness: 0.8 });
            const supportMaterial = new THREE.MeshStandardMaterial({ color: supportColor, roughness: 0.7 });
            const concreteMaterial = new THREE.MeshStandardMaterial({ color: concreteColor, roughness: 0.9 });
            const hutMaterial = new THREE.MeshStandardMaterial({ color: hutColor, roughness: 0.8 });

            // Helper to create boxes
            const createBox = (w, h, d, material, x, y, z) => {
                const geo = new THREE.BoxGeometry(w, h, d);
                const mesh = new THREE.Mesh(geo, material);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                towerGroup.add(mesh);
                return mesh;
            };
             // Helper to create cylinders
            const createCylinder = (rTop, rBot, h, material, x, y, z) => {
                const geo = new THREE.CylinderGeometry(rTop, rBot, h, 12); // 12 segments for supports
                const mesh = new THREE.Mesh(geo, material);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                towerGroup.add(mesh);
                return mesh;
            };

            // --- Base and Supports ---
            const supportPositions = [
                { x: platformWidth / 2 - supportRadius, z: platformDepth / 2 - supportRadius },
                { x: -platformWidth / 2 + supportRadius, z: platformDepth / 2 - supportRadius },
                { x: platformWidth / 2 - supportRadius, z: -platformDepth / 2 + supportRadius },
                { x: -platformWidth / 2 + supportRadius, z: -platformDepth / 2 + supportRadius },
            ];

            supportPositions.forEach(pos => {
                // Concrete Base
                createBox(supportRadius * 3, 0.8, supportRadius * 3, concreteMaterial, pos.x, 0.4, pos.z);
                // Green Support Pillar
                createCylinder(supportRadius, supportRadius, platformHeight2, supportMaterial, pos.x, platformHeight2 / 2 + 0.8, pos.z);
            });

            // --- Platforms ---
            // Platform 1 (Lower) - Extending slightly for stair landing
            createBox(platformWidth, plankThickness, platformDepth + 1, woodMaterial, 0, platformHeight1, 0.5); // Shifted Z
            // Platform 2 (Upper)
            createBox(platformWidth, plankThickness, platformDepth, woodMaterial, 0, platformHeight2, 0);

            // --- Hut ---
            const hutY = platformHeight2 + plankThickness / 2 + hutHeight / 2;
            // Walls
            createBox(hutSize, hutHeight, plankThickness, hutMaterial, 0, hutY, hutSize / 2 - plankThickness / 2); // Back
            createBox(hutSize, hutHeight, plankThickness, hutMaterial, 0, hutY, -hutSize / 2 + plankThickness / 2); // Front (with gaps for windows)
            createBox(plankThickness, hutHeight, hutSize - plankThickness*2, hutMaterial, hutSize / 2 - plankThickness / 2, hutY, 0); // Right
            createBox(plankThickness, hutHeight, hutSize - plankThickness*2, hutMaterial, -hutSize / 2 + plankThickness / 2, hutY, 0); // Left
            // Roof
            createBox(hutSize + plankThickness*2, plankThickness * 2, hutSize + plankThickness*2, woodMaterial, 0, platformHeight2 + hutHeight + plankThickness, 0);

             // --- Railings --- (Simplified Box Railings)
            const createRailings = (px, pz, width, depth, height) => {
                const railThickness = 0.15;
                // const postHeight = height + railThickness / 2; // Original post height calculation seems off
                const railTopY = height + railingHeight - railThickness / 2; // Y position for the top of the rail
                const postBottomY = height + plankThickness/2; // Posts start on top of platform
                const postTopY = height + railingHeight;
                const postMidY = (postBottomY + postTopY) / 2;
                const postActualHeight = postTopY - postBottomY;


                // Posts (simplified) - Adjusted Y position and height
                 createBox(railThickness*1.5, postActualHeight, railThickness*1.5, woodMaterial, px + width/2 - railThickness, postMidY, pz + depth/2 - railThickness);
                 createBox(railThickness*1.5, postActualHeight, railThickness*1.5, woodMaterial, px - width/2 + railThickness, postMidY, pz + depth/2 - railThickness);
                 createBox(railThickness*1.5, postActualHeight, railThickness*1.5, woodMaterial, px + width/2 - railThickness, postMidY, pz - depth/2 + railThickness);
                 createBox(railThickness*1.5, postActualHeight, railThickness*1.5, woodMaterial, px - width/2 + railThickness, postMidY, pz - depth/2 + railThickness);
                // Rails (simplified top rails) - Adjusted Y position
                 createBox(width, railThickness, railThickness, woodMaterial, px, railTopY, pz + depth / 2 - railThickness/2); // Back
                 createBox(width, railThickness, railThickness, woodMaterial, px, railTopY, pz - depth / 2 + railThickness/2); // Front
                 createBox(railThickness, railThickness, depth - railThickness, woodMaterial, px + width / 2 - railThickness/2, railTopY, pz); // Right Side
                 createBox(railThickness, railThickness, depth - railThickness, woodMaterial, px - width / 2 + railThickness/2, railTopY, pz); // Left Side
             };

            // Apply railings, adjusting for the extended lower platform
            createRailings(0, 0.5, platformWidth, platformDepth + 1, platformHeight1); // Railings for lower platform
            createRailings(0, 0, platformWidth, platformDepth, platformHeight2); // Railings for upper platform (hut area will overlap)


             // --- Stairs --- (Individual step boxes)
            const stairWidth = 1.2;
            const stairMaterial = new THREE.MeshStandardMaterial({ color: woodColor, roughness: 0.8});

            // Stairs from ground to lower platform (Platform 1)
            const stepHeight1 = 0.25;
            const stepDepth1 = 0.35;
            const numSteps1 = Math.ceil(platformHeight1 / stepHeight1);
            const horizontalRun1 = platformWidth * 0.8; // How far stairs extend horizontally
            const startX1 = -platformWidth / 2 - 0.5; // Starting X position relative to center
            const startZ1 = platformDepth / 2 + 1; // Starting Z position relative to center (align with extended platform)

             for(let i = 0; i < numSteps1; i++) {
                 const stepProgress = (i + 0.5) / numSteps1;
                 const stepY = stepProgress * platformHeight1;
                 const stepX = startX1 - stepProgress * horizontalRun1; // Move outwards diagonally
                 const stepZ = startZ1; // Keep Z constant for this flight
                 createBox(stairWidth, stepHeight1, stepDepth1, stairMaterial, stepX, stepY, stepZ);
            }

            // Stairs from lower platform (Platform 1) to upper platform (Platform 2)
             const stepHeight2 = 0.25;
             const stepDepth2 = 0.35;
             const heightDiff = platformHeight2 - platformHeight1;
             const numSteps2 = Math.ceil(heightDiff / stepHeight2);
             const horizontalRun2 = platformWidth * 0.8;
             const startX2 = platformWidth / 2 + 0.5; // Start from the other side for the second flight
             const startZ2 = -platformDepth/2; // Start Z at the back edge of upper platform

             for(let i = 0; i < numSteps2; i++) {
                 const stepProgress = (i + 0.5) / numSteps2;
                 const stepY = platformHeight1 + stepProgress * heightDiff;
                 const stepX = startX2 + stepProgress * horizontalRun2; // Move outwards diagonally the other way
                 const stepZ = startZ2; // Keep Z constant
                 createBox(stairWidth, stepHeight2, stepDepth2, stairMaterial, stepX, stepY, stepZ);
            }

            // --- Add simplified railings for stairs ---
            const createStairRailing = (startX, startZ, startY, endY, numSteps, horizontalRun, stairWidth, angleMultiplier) => {
                const railLength = Math.sqrt(Math.pow(endY - startY, 2) + Math.pow(horizontalRun, 2));
                const railAngle = Math.atan2(endY - startY, horizontalRun) * angleMultiplier;
                const midY = startY + (endY - startY) / 2;
                const midX = startX - (horizontalRun / 2) * angleMultiplier;

                const railGeo = new THREE.BoxGeometry(railLength, 0.15, 0.15); // Slightly thicker railing

                const railLeft = new THREE.Mesh(railGeo, woodMaterial);
                railLeft.position.set(midX, midY, startZ - stairWidth / 2);
                railLeft.rotation.z = railAngle;
                towerGroup.add(railLeft);

                const railRight = new THREE.Mesh(railGeo, woodMaterial);
                railRight.position.set(midX, midY, startZ + stairWidth / 2);
                railRight.rotation.z = railAngle;
                towerGroup.add(railRight);
            };

             // Railings for first flight
             createStairRailing(startX1, startZ1, 0, platformHeight1, numSteps1, horizontalRun1, stairWidth, 1);
             // Railings for second flight
             createStairRailing(startX2, startZ2, platformHeight1, platformHeight2, numSteps2, horizontalRun2, stairWidth, -1);


            return towerGroup;
        }

        // Add this function to spawn the boss zombie
        function spawnBossZombie() {
            // Create boss zombie container
            const bossContainer = new THREE.Group();
            
            // Scale for the boss (much larger than regular zombies)
            const scale = 3.0; 
            
            // Create boss zombie mesh
            const bossGroup = createBossZombie(scale);
            bossContainer.add(bossGroup);
            
            // Position boss at a random location around the player
            const angle = Math.random() * Math.PI * 2;
            const distance = 40; // Start a bit far away
            
            bossContainer.position.x = Math.cos(angle) * distance;
            bossContainer.position.z = Math.sin(angle) * distance;
            bossContainer.position.y = 0; // Ground level
            
            // Add a health bar above the boss
            const healthBarContainer = new THREE.Group();
            
            // Create health bar background
            const healthBarBg = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 0.2),
                new THREE.MeshBasicMaterial({ color: 0x333333 })
            );
            healthBarBg.position.y = 5 * scale; // Position above the boss head
            healthBarContainer.add(healthBarBg);
            
            // Create health bar foreground (actual health indicator)
            const healthBar = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 0.2),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            // Position slightly in front to avoid z-fighting
            healthBar.position.set(0, 5 * scale, 0.01);
            healthBar.scale.set(1, 1, 1); // Full health initially
            
            // Store reference to health bar for updates
            bossContainer.userData.healthBar = healthBar;
            bossContainer.userData.healthBarContainer = healthBarContainer;
            
            healthBarContainer.add(healthBar);
            bossContainer.add(healthBarContainer);
            
            // Boss properties
            const bossHealth = 50000; // INCREASED HEALTH
            bossContainer.userData.health = bossHealth;
            bossContainer.userData.initialHealth = bossHealth; // Store initial health for percentage calculations
            bossContainer.userData.speed = 0.008; // INCREASED SPEED (was 0.004)
            bossContainer.userData.isBoss = true;
            bossContainer.userData.animationPhase = Math.random() * Math.PI * 2;
            bossContainer.userData.poisonAttackCooldown = 5; // 5 seconds initial cooldown before first attack
            bossContainer.userData.initialHealth = bossHealth;
            bossContainer.userData.speed = 0.008;
            bossContainer.userData.isBoss = true;
            bossContainer.userData.animationPhase = Math.random() * Math.PI * 2;
            bossContainer.userData.poisonAttackCooldown = 5; // 5 seconds initial cooldown before first attack
            bossContainer.userData.poisonAttackCount = 0; // Track how many poison attacks have been made
            bossContainer.userData.chainsawAttackCooldown = 0; // Cooldown for chainsaw ground wave attack
            bossContainer.name = "bossZombie";
            
            // Make sure all child objects reference back to the parent
            bossContainer.traverse(child => {
                child.userData.zombieRoot = bossContainer;
            });
            
            console.log(`Created Boss zombie with ${bossHealth} health`);
            
            scene.add(bossContainer);
            zombies.push(bossContainer);
            bossZombie = bossContainer; // Store reference to the boss
        }

        // Create detailed boss zombie mesh based on the uploaded image
        // Create detailed boss zombie mesh
function createBossZombie(scale) {
    const bossGroup = new THREE.Group();
    
    // --- Colors ---
    const skinColor = new THREE.Color(0x6f946a); // Main green skin
    const skinHighlight = new THREE.Color(0x8db088); // Lighter green
    const skinShadow = new THREE.Color(0x5a7a56); // Darker green
    const shirtColor = new THREE.Color(0x4f7b7c); // Teal/Blue shirt
    const pantsColor = new THREE.Color(0x4a4a4a); // Dark grey/brown pants
    const bloodColor = new THREE.Color(0x8a0303); // Dark red for blood
    const chainsawBodyColor = new THREE.Color(0xdd8830); // Orange chainsaw body
    const chainsawBladeColor = new THREE.Color(0x808080); // Grey chainsaw blade
    const chainsawHandleColor = new THREE.Color(0x505050); // Dark grey handle
    
    // Standard material setup
    const createMaterial = (color, roughness = 0.8, metalness = 0.1) => {
        return new THREE.MeshStandardMaterial({
            color: color,
            roughness: roughness,
            metalness: metalness,
            emissive: 0x000000,
            flatShading: false // Smooth shading for rounder look
        });
    };
    
    // --- HEAD ---
    const headGroup = new THREE.Group();
    
    // Rounded head base (sphere instead of cubes)
    const headRadius = 0.45 * scale;
    const headGeometry = new THREE.SphereGeometry(headRadius, 32, 32);
    const headMaterial = createMaterial(skinColor);
    const head = new THREE.Mesh(headGeometry, headMaterial);
    headGroup.add(head);
    
    // Create a jaw/mouth area that extends forward a bit
    const jawGeometry = new THREE.SphereGeometry(headRadius * 0.7, 32, 16);
    const jawMaterial = createMaterial(skinShadow);
    const jaw = new THREE.Mesh(jawGeometry, jawMaterial);
    jaw.scale.set(0.8, 0.5, 0.6);
    jaw.position.set(0, -headRadius * 0.4, headRadius * 0.5);
    headGroup.add(jaw);
    
    // Bloodstain details
    for (let i = 0; i < 8; i++) {
        const bloodSize = Math.random() * 0.08 * scale + 0.03 * scale;
        const bloodGeometry = new THREE.SphereGeometry(bloodSize, 8, 8);
        const bloodMaterial = createMaterial(bloodColor, 0.7, 0.3);
        const bloodSpot = new THREE.Mesh(bloodGeometry, bloodMaterial);
        
        // Random position on head
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        bloodSpot.position.set(
            Math.sin(phi) * Math.cos(theta) * headRadius * 0.9,
            Math.sin(phi) * Math.sin(theta) * headRadius * 0.9,
            Math.cos(phi) * headRadius * 0.9
        );
        head.add(bloodSpot);
    }
    
    // Eyes (glowing red)
    const eyeSize = 0.08 * scale;
    const eyeMaterial = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 0.8,
        transparent: true,
        opacity: 0.9
    });
    
    [-1, 1].forEach(side => {
        const eye = new THREE.Mesh(
            new THREE.SphereGeometry(eyeSize, 16, 16),
            eyeMaterial
        );
        eye.position.set(side * headRadius * 0.4, headRadius * 0.1, headRadius * 0.8);
        headGroup.add(eye);
        
        // Add pupil
        const pupil = new THREE.Mesh(
            new THREE.SphereGeometry(eyeSize * 0.5, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0x000000 })
        );
        pupil.position.z = eyeSize * 0.5;
        eye.add(pupil);
    });
    
    // Mouth (jagged teeth)
    const mouthWidth = 0.3 * scale;
    const mouthHeight = 0.1 * scale;
    const mouthZ = headRadius * 0.85;
    const mouthY = -headRadius * 0.3;
    
    const mouthGeometry = new THREE.BoxGeometry(mouthWidth, mouthHeight, mouthHeight * 0.5);
    const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x220000 });
    const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
    mouth.position.set(0, mouthY, mouthZ);
    headGroup.add(mouth);
    
    // Teeth
    const toothMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xe0e0b0, 
        roughness: 0.7,
        metalness: 0.05
    });
    
    for (let i = 0; i < 6; i++) {
        const toothWidth = 0.04 * scale;
        const toothHeight = 0.06 * scale * (1 + Math.random() * 0.5); // Varied heights
        const tooth = new THREE.Mesh(
            new THREE.ConeGeometry(toothWidth, toothHeight, 4),
            toothMaterial
        );
        
        // Position teeth along mouth
        const toothX = (i - 2.5) * (mouthWidth / 5);
        const toothZ = mouthZ + mouthHeight * 0.25;
        
        // Randomly position top or bottom row
        const isUpperTooth = Math.random() > 0.5;
        const toothY = mouthY + (isUpperTooth ? mouthHeight * 0.5 : -mouthHeight * 0.5);
        
        tooth.position.set(toothX, toothY, toothZ);
        tooth.rotation.x = isUpperTooth ? Math.PI : 0; // Rotate upper teeth
        headGroup.add(tooth);
    }
    
    // Position head
    headGroup.position.y = 2.2 * scale;
    bossGroup.add(headGroup);
    
    // --- TORSO ---
    const torsoGroup = new THREE.Group();
    
    // Rounded, fat torso (wide middle)
    const torsoHeight = 1.8 * scale;
    const torsoWidth = 1.8 * scale;  // Wider for fat look
    const torsoDepth = 1.2 * scale;  // Deeper for fat look
    
    // Use spherical geometry for rounder look
    const torsoGeometry = new THREE.SphereGeometry(1, 32, 24);
    const torsoMaterial = createMaterial(shirtColor, 0.9, 0.1);
    const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
    torso.scale.set(torsoWidth/2, torsoHeight/2, torsoDepth/2);
    torsoGroup.add(torso);
    
    // Add blood splatters to torso
    for (let i = 0; i < 20; i++) {
        const bloodSize = Math.random() * 0.12 * scale + 0.05 * scale;
        const bloodGeometry = new THREE.SphereGeometry(bloodSize, 8, 8);
        const bloodMaterial = createMaterial(bloodColor, 0.7, 0.3);
        const bloodSpot = new THREE.Mesh(bloodGeometry, bloodMaterial);
        
        // Random position on torso surface
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        const radius = 0.9; // Keep slightly inside the surface
        
        bloodSpot.position.set(
            Math.sin(phi) * Math.cos(theta) * radius,
            Math.sin(phi) * Math.sin(theta) * radius,
            Math.cos(phi) * radius
        );
        
        torso.add(bloodSpot);
    }
    
    // Position torso
    torsoGroup.position.y = 0.9 * scale;
    bossGroup.add(torsoGroup);
    
    // --- ARMS ---
    for (let side = -1; side <= 1; side += 2) {
        const armGroup = new THREE.Group();
        
        // Parameters
        const armLength = 1.5 * scale;
        const shoulderRadius = 0.35 * scale;
        const elbowRadius = 0.3 * scale;
        const handRadius = 0.25 * scale;
        
        // Shoulder (rounded)
        const shoulderGeometry = new THREE.SphereGeometry(shoulderRadius, 24, 24);
        const shoulderMaterial = createMaterial(skinColor);
        const shoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
        armGroup.add(shoulder);
        
        // Upper arm (cylinder)
        const upperArmLength = armLength * 0.45;
        const upperArmGeometry = new THREE.CylinderGeometry(shoulderRadius * 0.9, elbowRadius, upperArmLength, 24);
        const upperArmMaterial = createMaterial(skinColor);
        const upperArm = new THREE.Mesh(upperArmGeometry, upperArmMaterial);
        upperArm.position.y = -upperArmLength/2;
        armGroup.add(upperArm);
        
        // Elbow (rounded)
        const elbowGeometry = new THREE.SphereGeometry(elbowRadius, 24, 24);
        const elbowMaterial = createMaterial(skinColor);
        const elbow = new THREE.Mesh(elbowGeometry, elbowMaterial);
        elbow.position.y = -upperArmLength;
        armGroup.add(elbow);
        
        // Forearm (cylinder)
        const forearmLength = armLength * 0.45;
        const forearmGeometry = new THREE.CylinderGeometry(elbowRadius, handRadius, forearmLength, 24);
        const forearmMaterial = createMaterial(skinColor);
        const forearm = new THREE.Mesh(forearmGeometry, forearmMaterial);
        forearm.position.y = -upperArmLength - forearmLength/2;
        armGroup.add(forearm);
        
        // Hand (rounded)
        const handGeometry = new THREE.SphereGeometry(handRadius, 24, 24);
        const handMaterial = createMaterial(skinColor);
        const hand = new THREE.Mesh(handGeometry, handMaterial);
        hand.position.y = -upperArmLength - forearmLength;
        armGroup.add(hand);
        
        // Position arm
        armGroup.position.set(
            side * (torsoWidth/2 - shoulderRadius/2),
            torsoGroup.position.y + torsoHeight/2 - shoulderRadius/2,
            0
        );
        
        // Set proper arm name
        armGroup.name = side > 0 ? 'rightArm' : 'leftArm';
        bossGroup.add(armGroup);
        
        // --- CHAINSAW (Left Arm Only) ---
        if (side === -1) {
            const chainsawGroup = new THREE.Group();
            
            // BIGGER Chainsaw body (orange box with rounded edges)
            const csBodyWidth = 0.6 * scale;  // Increased size
            const csBodyHeight = 0.7 * scale; // Increased size
            const csBodyDepth = 0.5 * scale;  // Increased size
            
            const csBodyGeometry = new THREE.BoxGeometry(csBodyWidth, csBodyHeight, csBodyDepth);
            const csBodyMaterial = createMaterial(chainsawBodyColor, 0.7, 0.3);
            const csBody = new THREE.Mesh(csBodyGeometry, csBodyMaterial);
            chainsawGroup.add(csBody);
            
            // Longer blade (grey)
            const csBladeLength = 1.5 * scale; // Longer blade
            const csBladeHeight = 0.3 * scale;
            const csBladeDepth = 0.15 * scale;
            
            const csBladeGeometry = new THREE.BoxGeometry(csBladeLength, csBladeHeight, csBladeDepth);
            const csBladeMaterial = createMaterial(chainsawBladeColor, 0.3, 0.8);
            const csBlade = new THREE.Mesh(csBladeGeometry, csBladeMaterial);
            csBlade.position.x = csBodyWidth * 0.3 + csBladeLength * 0.4; // Position blade forward
            chainsawGroup.add(csBlade);
            
            // Add chainsaw teeth (more detailed than before)
            const teethCount = 12; // More teeth
            const toothSize = 0.08 * scale;
            const toothGeometry = new THREE.ConeGeometry(toothSize, toothSize*2, 4);
            const toothMaterial = createMaterial(0xdddddd, 0.3, 0.9);
            
            for (let i = 0; i < teethCount; i++) {
                const tooth = new THREE.Mesh(toothGeometry, toothMaterial);
                const posX = i * (csBladeLength * 0.8 / teethCount) - csBladeLength * 0.3;
                tooth.position.set(posX + csBodyWidth * 0.3 + csBladeLength * 0.4, -csBladeHeight/2 - toothSize * 0.5, 0);
                tooth.rotation.z = Math.PI; // Point downward
                chainsawGroup.add(tooth);
            }
            
            // Handle (dark grey)
            const csHandleWidth = 0.2 * scale;
            const csHandleHeight = 0.6 * scale;
            const csHandleDepth = 0.2 * scale;
            const csHandleGeometry = new THREE.CylinderGeometry(csHandleWidth*0.5, csHandleWidth*0.5, csHandleHeight, 16);
            const csHandleMaterial = createMaterial(chainsawHandleColor, 0.9, 0.2);
            const csHandle = new THREE.Mesh(csHandleGeometry, csHandleMaterial);
            csHandle.rotation.x = Math.PI / 2; // Rotate to horizontal
            csHandle.position.set(0, -csBodyHeight * 0.2, -csBodyDepth * 0.7);
            chainsawGroup.add(csHandle);
            
            // Blood splatter on the blade and chainsaw
            for (let i = 0; i < 10; i++) {
                const bloodSpotSize = Math.random() * 0.05 * scale + 0.02 * scale;
                const bloodSpotGeometry = new THREE.SphereGeometry(bloodSpotSize, 8, 8);
                const bloodSpotMaterial = createMaterial(bloodColor, 0.6, 0.4);
                const bloodSpot = new THREE.Mesh(bloodSpotGeometry, bloodSpotMaterial);
                
                // Random position on blade or body
                const onBlade = Math.random() > 0.4;
                if (onBlade) {
                    bloodSpot.position.set(
                        Math.random() * csBladeLength - csBladeLength * 0.5 + csBodyWidth * 0.3 + csBladeLength * 0.4,
                        (Math.random() - 0.5) * csBladeHeight,
                        (Math.random() - 0.5) * csBladeDepth * 1.2
                    );
                    csBlade.add(bloodSpot);
                } else {
                    bloodSpot.position.set(
                        (Math.random() - 0.5) * csBodyWidth,
                        (Math.random() - 0.5) * csBodyHeight,
                        (Math.random() - 0.5) * csBodyDepth * 1.2
                    );
                    csBody.add(bloodSpot);
                }
            }
            
            // Position and rotate chainsaw relative to the arm
            chainsawGroup.position.y = -upperArmLength - forearmLength; // Position at hand
            chainsawGroup.position.x = handRadius * 0.5; // Slight offset
            chainsawGroup.rotation.z = -Math.PI / 12; // Angle slightly
            chainsawGroup.rotation.y = -Math.PI / 4; // Turn outward more
            
            armGroup.add(chainsawGroup);
            armGroup.userData.holdsChainsaw = true; // Flag for animation
        }
    }
    
    // --- LEGS ---
    for (let side = -1; side <= 1; side += 2) {
        const legGroup = new THREE.Group();
        
        // Parameters
        const legLength = 1.6 * scale;
        const hipRadius = 0.4 * scale;
        const kneeRadius = 0.35 * scale;
        const ankleRadius = 0.25 * scale;
        
        // Hip (rounded)
        const hipGeometry = new THREE.SphereGeometry(hipRadius, 24, 24);
        const hipMaterial = createMaterial(pantsColor, 0.8, 0.1);
        const hip = new THREE.Mesh(hipGeometry, hipMaterial);
        legGroup.add(hip);
        
        // Thigh (cylinder)
        const thighLength = legLength * 0.45;
        const thighGeometry = new THREE.CylinderGeometry(hipRadius * 0.9, kneeRadius, thighLength, 24);
        const thighMaterial = createMaterial(pantsColor, 0.8, 0.1);
        const thigh = new THREE.Mesh(thighGeometry, thighMaterial);
        thigh.position.y = -thighLength/2;
        legGroup.add(thigh);
        
        // Knee (rounded)
        const kneeGeometry = new THREE.SphereGeometry(kneeRadius, 24, 24);
        const kneeMaterial = createMaterial(pantsColor, 0.8, 0.1);
        const knee = new THREE.Mesh(kneeGeometry, kneeMaterial);
        knee.position.y = -thighLength;
        legGroup.add(knee);
        
        // Calf (cylinder)
        const calfLength = legLength * 0.45;
        const calfGeometry = new THREE.CylinderGeometry(kneeRadius, ankleRadius, calfLength, 24);
        const calfMaterial = createMaterial(skinColor, 0.8, 0.1); // Green skin below pants
        const calf = new THREE.Mesh(calfGeometry, calfMaterial);
        calf.position.y = -thighLength - calfLength/2;
        legGroup.add(calf);
        
        // Foot (rounded)
        const footWidth = 0.3 * scale;
        const footHeight = 0.15 * scale;
        const footLength = 0.5 * scale;
        const footGeometry = new THREE.BoxGeometry(footWidth, footHeight, footLength);
        const footMaterial = createMaterial(0x222222, 0.9, 0.1);
        const foot = new THREE.Mesh(footGeometry, footMaterial);
        foot.position.set(0, -thighLength - calfLength - footHeight/2, footLength/4);
        legGroup.add(foot);
        
        // Position leg
        legGroup.position.set(
            side * (torsoWidth/3), // Legs further apart for wider stance
            torsoGroup.position.y - torsoHeight/2 + hipRadius/2,
            0
        );
        
        // Set proper leg name
        legGroup.name = side > 0 ? 'rightLeg' : 'leftLeg';
        bossGroup.add(legGroup);
    }
    
    return bossGroup;
}

        // Update the boss animation logic in the animate function
        // Find the section: if (bossZombie && bossZombie.userData.healthBar)
        if (bossZombie && bossZombie.userData.healthBar) {
            // Update boss health bar to face camera
            bossZombie.userData.healthBarContainer.lookAt(camera.position);
            
            // Update health bar fill based on current health
            const healthPercent = bossZombie.userData.health / bossZombie.userData.initialHealth;
            bossZombie.userData.healthBar.scale.x = Math.max(0, healthPercent);
            
            // Position health bar fill to align with left edge
            bossZombie.userData.healthBar.position.x = -1 + healthPercent;
            
            // Boss Animation
            bossZombie.userData.animationPhase += 0.08; // Slower animation for boss
            const phase = bossZombie.userData.animationPhase;
            // Increase swing factor for more pronounced movement
            const swingFactor = 0.25; 
            
            bossZombie.traverse(child => {
                if (child.name === 'leftArm') {
                    if (child.userData.holdsChainsaw) {
                        // Hold chainsaw more steadily forward, less swing, slight tremble
                        child.rotation.x = Math.PI / 8 + Math.sin(phase * 3) * 0.04;
                        child.rotation.z = -Math.PI / 8 + Math.cos(phase * 3) * 0.02; 
                    } else {
                         child.rotation.x = Math.sin(phase) * swingFactor;
                    }
                } else if (child.name === 'rightArm') {
                    child.rotation.x = -Math.sin(phase) * swingFactor; // Keep right arm swing
                } else if (child.name === 'leftLeg') {
                     child.rotation.x = -Math.sin(phase) * swingFactor; // More pronounced leg swing
                } else if (child.name === 'rightLeg') {
                     child.rotation.x = Math.sin(phase) * swingFactor;
                } 
            });
        }

        // Update collision with boss zombie - modify the existing zombie collision check
        if (zombie.position.distanceTo(camera.position) < 1.5) {
            // Different damage for different enemy types
            let damage = 1; // Default for small zombies
            
            if (zombie.userData.isToughZombie) {
                damage = 5; // Tough zombies
            } else if (zombie.userData.isRobot) {
                damage = 0; // Robots deal damage with lasers, not collision
            } else if (zombie.userData.isBoss) {
                damage = 50; // Boss zombie deals massive damage
            }
            
            playerHealth -= damage;
            document.getElementById('health').textContent = `Health: ${playerHealth}`;
            
            if (playerHealth <= 0) {
                gameOver();
            }
        }

        // Update when boss is defeated
        function processHits(hits, damage, range, canHitMultiple) {
            const processedTargets = new Set();

            for (const hit of hits) {
                if (hit.distance > range) continue;
                const hitObject = hit.object.userData.zombieRoot || hit.object;
                if (processedTargets.has(hitObject) && !canHitMultiple) continue;
                processedTargets.add(hitObject);

                // Apply damage
                if (hitObject.userData.isRobot) {
                    hitObject.userData.hitsTaken = (hitObject.userData.hitsTaken || 0) + 1;
                    hitObject.userData.health = hitObject.userData.maxHealth - hitObject.userData.hitsTaken;
                    console.log(`Robot hit! Hits taken: ${hitObject.userData.hitsTaken}/4, Health remaining: ${hitObject.userData.health}`);
                } else {
                    hitObject.userData.health -= damage;
                    hitObject.userData.hitsTaken = (hitObject.userData.hitsTaken || 0) + 1;
                    console.log(`Zombie hit! Type: ${hitObject.userData.isToughZombie ? 'Tough' : 'Normal'}, Health: ${hitObject.userData.health}, Hits taken: ${hitObject.userData.hitsTaken}`);
                }

                addHitFlashEffect(hitObject);

                // Check if object is destroyed
                if (hitObject.userData.health <= 0) {
                    let enemyRemoved = false; // Flag to track if enemy was removed
                    if (hitObject.userData.isRobot) {
                        console.log("Robot destroyed after exactly 4 hits!");
                        scene.remove(hitObject);
                        robots = robots.filter(r => r !== hitObject);
                        zombies = zombies.filter(z => z !== hitObject);
                        enemyRemoved = true;
                    } else if (hitObject.userData.isBoss) {
                        console.log("BOSS DEFEATED!!!");
                        
                        // Use the global helper function instead of inline code
                        showRoundTransitionOverlay();
                        
                        scene.remove(hitObject);
                        zombies = zombies.filter(z => z !== hitObject);
                        bossZombie = null;
                        enemyRemoved = true; // Keep this true for score and potential powerup drop
                    } else {
                        // Regular zombies and crawlers
                        console.log("Zombie killed!");
                        scene.remove(hitObject);
                        zombies = zombies.filter(z => z !== hitObject);
                        enemyRemoved = true;
                    }

                    if (enemyRemoved) {
                        // Update score
                        let scorePoints = 100;
                        if (hitObject.userData.isToughZombie) scorePoints = 500;
                        else if (hitObject.userData.isRobot) scorePoints = 250;
                        else if (hitObject.userData.isCrawler) scorePoints = 200;
                        else if (hitObject.userData.isBoss) scorePoints = 1000;
                        score += scorePoints;
                        document.getElementById('score').textContent = `Score: ${score}`;

                        // Power-up Drop
                        const enemyPosition = hitObject.position.clone();
                        if (Math.random() < 0.50) {
                            const powerupTypes = ['shotgun', 'sniper', 'grenade'];
                            const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                            spawnPowerup(randomType, enemyPosition);
                            console.log(`Spawning ${randomType} power-up from enemy kill`);
                        }

                        // Spawn new enemy
                        setTimeout(() => {
                            // Respawn logic based on currentWave
                            if (currentWave === 3) {
                                const rand = Math.random();
                                if (rand < 0.3) spawnRobot();
                                else if (rand < 0.6) spawnZombie(true); // Tough zombie in wave 3
                                else spawnZombie(false);
                            } else if (currentWave === 2) {
                                const spawnToughZombie = Math.random() < 0.4;
                                spawnZombie(spawnToughZombie); // Tough zombie in wave 2 (random chance)
                            } else if (currentWave === 1) {
                                // *** Changed this line: Only spawn regular zombies in wave 1 ***
                                spawnZombie(false);
                            }
                        }, Math.random() * 2000 + 1000);
                    }
                    
                    // Stop processing further hits on this shot if the weapon can't hit multiple targets
                    if (!canHitMultiple) break; 
                }

                // Reduce damage for subsequent pellets in shotgun blast
                if (canHitMultiple && currentWeapon === 'shotgun') {
                    damage = Math.max(10, damage - 5);
                }
            }
        }

        // A helper function to display the round transition overlay
        function showRoundTransitionOverlay() {
            console.log("Attempting to show round transition overlay");
            const overlay = document.getElementById('round-transition-overlay');
            if (overlay) {
                console.log("Found overlay, setting display:flex");
                overlay.style.display = 'flex';
                
                // Hide after 5 seconds
                setTimeout(() => {
                    console.log("Hiding overlay after timeout");
                    overlay.style.display = 'none';
                }, 5000);
            } else {
                console.error("ERROR: round-transition-overlay element not found!");
            }
        }

        
        // Add scope overlay element
        scopeOverlay.style.position = 'absolute';
        scopeOverlay.style.top = '0';
        scopeOverlay.style.left = '0';
        scopeOverlay.style.width = '100%';
        scopeOverlay.style.height = '100%';
        scopeOverlay.style.backgroundImage = 'radial-gradient(circle, transparent 0%, rgba(0,0,0,0.8) 100%)';
        scopeOverlay.style.pointerEvents = 'none';
        scopeOverlay.style.zIndex = '999';
        scopeOverlay.style.display = 'none';
        document.body.appendChild(scopeOverlay);

        // Function to toggle scope
        function toggleScope() {
            console.log("Toggling scope, current weapon:", currentWeapon);
            if (currentWeapon !== 'sniper') {
                 console.log("Not a sniper, returning");
                return;
            }
            
            isScopeActive = !isScopeActive;
            console.log("Scope active:", isScopeActive);
            
            if (scopeOverlay) {
                scopeOverlay.style.display = isScopeActive ? 'block' : 'none';
            }
            
            if (camera) {
                if (isScopeActive) {
                    // Set zoom level to 6x
                    camera.fov = SCOPE_FOV;
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    console.log("Scope activated, FOV:", camera.fov);
                } else {
                    // Reset camera FOV to default
                    camera.fov = DEFAULT_FOV;
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    console.log("Scope deactivated, FOV:", camera.fov);
                }
            }
        }

        // Add event listener for scope toggle
        document.addEventListener('keydown', (event) => {
            if (event.key.toLowerCase() === 'q' && currentWeapon === 'sniper') {
                toggleScope();
            }
        });

        // Function for boss zombie to shoot poison projectile
        function shootBossPoison() {
            
            if (!bossZombie) return;

            bossZombie.userData.poisonAttackCount = (bossZombie.userData.poisonAttackCount || 0) + 1;
    
    // Check if we've reached 4 poison attacks to trigger chainsaw attack
            if (bossZombie.userData.poisonAttackCount >= 6) {
        // Reset poison counter
                bossZombie.userData.poisonAttackCount = 0;
        
        // Trigger chainsaw ground wave attack after a short delay
                setTimeout(() => {
                    if (bossZombie && !isGameOver) {
                        performChainsawGroundWaveAttack();
                    }
                }, 1500); // 1.5 second delay for dramatic effect
            }
            
            // Create poison projectile geometry (sphere)
            const poisonGeometry = new THREE.SphereGeometry(0.5, 12, 12);
            
            // Glowing green material
            const poisonMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.8
            });
            
            // Create poison mesh
            const poisonProjectile = new THREE.Mesh(poisonGeometry, poisonMaterial);
            
            // Calculate starting position at boss's mouth
            const startPosition = bossZombie.position.clone();
            startPosition.y += 3 * 3; // Adjust based on boss scale (multiply by scale factor 3)
            startPosition.z += 0.5 * 3; // Slightly forward from center
            poisonProjectile.position.copy(startPosition);
            
            // Get direction to player
            const direction = new THREE.Vector3();
            direction.subVectors(camera.position, startPosition).normalize();
            
            // Add velocity for movement (slower than bullets)
            poisonProjectile.userData.velocity = direction.multiplyScalar(1.5);
            poisonProjectile.userData.lifespan = 100; // How long the projectile lives
            
            // Add poison glow effect
            const poisonLight = new THREE.PointLight(0x00ff00, 1, 5);
            poisonProjectile.add(poisonLight);
            
            // Add to scene and tracking array
            scene.add(poisonProjectile);
            poisonProjectiles.push(poisonProjectile);
            
            // Add poison sound effect
            if (audioContext) {
                const poisonSound = audioContext.createOscillator();
                poisonSound.type = 'sawtooth';
                poisonSound.frequency.setValueAtTime(220, audioContext.currentTime);
                
                const poisonGain = audioContext.createGain();
                poisonGain.gain.setValueAtTime(0.05, audioContext.currentTime);
                poisonGain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.7);
                
                poisonSound.connect(poisonGain);
                poisonGain.connect(audioContext.destination);
                
                poisonSound.start();
                poisonSound.stop(audioContext.currentTime + 0.7);
            }
            
            // Create poison trail effect
            createPoisonTrail(poisonProjectile);
        }
        
        // Function to create poison trail effect
        function createPoisonTrail(projectile) {
            // Create particles that follow behind the poison projectile
            const numParticles = 8;
            
            for (let i = 0; i < numParticles; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 6, 6);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x88ff88,
                    transparent: true,
                    opacity: 0.6
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Position slightly behind the projectile
                particle.position.copy(projectile.position);
                particle.position.add(projectile.userData.velocity.clone().multiplyScalar(-0.3 * i));
                
                // Store reference to parent projectile and offset
                particle.userData.projectile = projectile;
                particle.userData.offset = -0.3 * i;
                
                scene.add(particle);
                
                // Add particle to projectile's userData for tracking
                if (!projectile.userData.trailParticles) {
                    projectile.userData.trailParticles = [];
                }
                projectile.userData.trailParticles.push(particle);
            }
        }

// Add new function for the chainsaw ground wave attack
function performChainsawGroundWaveAttack() {
    if (!bossZombie || isGameOver) return;

    // Play the ZomieShouting.mp3 sound
    const zombieShoutSound = new Audio('ZomieShouting.mp3');
    zombieShoutSound.volume = 0.8; // Set volume to 80%
    zombieShoutSound.play();

    // Create the waves immediately after the sound starts << MOVED HERE
    createGroundWave(0);
    setTimeout(() => createGroundWave(-Math.PI/6), 250);
    setTimeout(() => createGroundWave(Math.PI/6), 500);

    // Start the chainsaw arm animation (without it triggering waves)
    animateChainsawAttack(); // << REMOVED the callback: () => { ... }
}

// Animate the chainsaw arm swinging down
function animateChainsawAttack() {
    if (!bossZombie) return;
    
    console.log("Attempting to animate chainsaw attack..."); // Log start
    
    // Find the chainsaw arm
    let chainsawArm = null;
    bossZombie.traverse(child => {
        // Log each child being checked
        console.log(`Traversing child: ${child.name}, holdsChainsaw: ${child.userData.holdsChainsaw}`); 
        if (child.name === 'leftArm' && child.userData.holdsChainsaw) {
            chainsawArm = child;
            console.log("Found chainsaw arm!", chainsawArm); // Log success
        }
    });
    
    if (!chainsawArm) {
        console.error("Chainsaw arm NOT found!"); // Log failure
        return; // Exit if arm not found
    }
    
    console.log("Chainsaw arm found, starting animation."); // Log proceeding

    // Store original rotations to restore later
    const originalRotX = chainsawArm.rotation.x;
    const originalRotZ = chainsawArm.rotation.z;
    
    // Create a dramatic swing animation
    const startTime = performance.now();
    const duration = 800; // 1 second for full animation
    
    // Animation function
    function animateSwing() {
        const now = performance.now();
        const elapsed = now - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Log progress value
        console.log(`animateSwing progress: ${progress.toFixed(3)}`);

        // First half - raise arm
        if (progress < 0.3) {
            const raiseProg = progress / 0.3;
            chainsawArm.rotation.x = originalRotX - Math.PI/2 * raiseProg;
            chainsawArm.rotation.z = originalRotZ - Math.PI/6 * raiseProg;
        } 
        // Second half - slam down
        else if (progress < 0.7) {
            const slamProg = (progress - 0.3) / 0.4;
            chainsawArm.rotation.x = originalRotX - Math.PI/2 + Math.PI * slamProg;
            chainsawArm.rotation.z = originalRotZ - Math.PI/6 + Math.PI/3 * slamProg;
            
            // At midpoint of slam (progress ~0.5), trigger ground impact
            if (progress > 0.49 && progress < 0.51) {
                //console.log("Calling callback to create ground waves..."); // Log before callback
                
                // Play chainsaw slam sound effect
                playChainsawSlamSound();
            }
        } 
        // Final part - return to original
        else {
            const returnProg = (progress - 0.7) / 0.3;
            chainsawArm.rotation.x = originalRotX + Math.PI/2 - Math.PI/2 * returnProg;
            chainsawArm.rotation.z = originalRotZ + Math.PI/6 - Math.PI/6 * returnProg;
        }
        
        if (progress < 1) {
            requestAnimationFrame(animateSwing);
        } else {
            // Restore original position
            chainsawArm.rotation.x = originalRotX;
            chainsawArm.rotation.z = originalRotZ;
        }
    }
    
    // Start animation
    animateSwing();
}

// Create the chainsaw ground wave
function createGroundWave(angle) {
    console.log(`Creating ground wave with angle: ${angle}`); // Log start of createGroundWave
    if (!bossZombie) return;
    
    // Position wave starting at the boss
    const startPos = bossZombie.position.clone();
    startPos.y = 0.1; // Just above ground
    
    // Get direction to player, then rotate by angle parameter
    const direction = new THREE.Vector3();
    direction.subVectors(camera.position, startPos).normalize();
    direction.y = 0; // Keep wave along ground
    
    // Apply the angle offset
    const rotationMatrix = new THREE.Matrix4().makeRotationY(angle);
    direction.applyMatrix4(rotationMatrix);
    
    // Wave settings
    const waveSpeed = 12;
    const waveColor = 0x00FFFF; // Cyan color for wave
    const segmentCount = 5; // Number of wave segments
    const maxWaveDistance = 40; // Maximum travel distance
    const waveMeshes = [];
    
    // Create wave segments as curved arcs
    for (let i = 0; i < segmentCount; i++) {
        // Create curved arc geometry
        const arcRadius = 1.5 + (i * 0.6); // Increasing radius for each segment
        const arcThickness = 0.2; // Thickness of the arc
        const arcAngle = Math.PI * 0.6; // 60 degree arc (like in the image)
        
        // Create a curved path for the arc
        const arcCurve = new THREE.EllipseCurve(
            0, 0,                        // Center x, y
            arcRadius, arcRadius,        // x radius, y radius
            -arcAngle/2, arcAngle/2,     // Start angle, end angle
            false,                       // Clockwise?
            0                            // Rotation
        );
        
        // Create points along the curve
        const arcPoints = arcCurve.getPoints(16);
        const arcGeometry = new THREE.BufferGeometry().setFromPoints(arcPoints);
        
        // Create the arc with a line material
        const arcMaterial = new THREE.LineBasicMaterial({ 
            color: waveColor,
            linewidth: 2 + i, // Increase line width for each segment
            opacity: 0.8,
            transparent: true
        });
        
        // Create the line arc
        const arcLine = new THREE.Line(arcGeometry, arcMaterial);
        
        // Make the arc vertical and face the direction
        arcLine.rotation.x = Math.PI / 2; // Rotate to be vertical
        
        // Create a group to hold the wave
        const waveGroup = new THREE.Group();
        waveGroup.add(arcLine);
        
        // Add glow effect
        const waveLight = new THREE.PointLight(waveColor, 0.8, 3);
        waveGroup.add(waveLight);
        
        // Set initial position and store data
        waveGroup.position.copy(startPos);
        waveGroup.userData = {
            distance: i * 3, // Start with spacing between waves
            maxDistance: maxWaveDistance,
            direction: direction.clone(),
            startPos: startPos.clone(),
            speed: waveSpeed - (i * 1), // Slower speed for later segments
            arcRadius: arcRadius,
            opacity: 0.8,
        };
        
        // Orient the wave to face the player along the ground
        const lookAtPos = new THREE.Vector3().copy(startPos).add(direction);
        lookAtPos.y = startPos.y; // Keep at same height
        waveGroup.lookAt(lookAtPos);
        waveGroup.rotation.x += Math.PI / 2; // ADD THIS LINE
        
        // Add to scene and tracking array
        scene.add(waveGroup);
        waveMeshes.push(waveGroup);
    }
    
    // Create additional visual effects at impact point
    const impactLight = new THREE.PointLight(waveColor, 1.2, 4);
    impactLight.position.copy(startPos);
    impactLight.position.y += 0.1;
    scene.add(impactLight);
    
    // Fade out the impact light
    const startTime = performance.now();
    function fadeImpactLight() {
        const now = performance.now();
        const elapsed = (now - startTime) / 1000;
        
        if (elapsed < 1.5) {
            impactLight.intensity = 1.2 * (1 - elapsed/1.5);
            requestAnimationFrame(fadeImpactLight);
        } else {
            scene.remove(impactLight);
        }
    }
    fadeImpactLight();
    
    // Animate wave movement and expansion
    function animateWave() {
        let stillActive = false;
        
        waveMeshes.forEach(wave => {
            // Move wave along direction
            wave.userData.distance += wave.userData.speed * 0.06;
            
            // Update position
            const newPos = wave.userData.startPos.clone().add(
                wave.userData.direction.clone().multiplyScalar(wave.userData.distance)
            );
            wave.position.copy(newPos);
            
            // Scale the wave as it travels (growing effect)
            const scaleFactor = 1 + (wave.userData.distance * 0.06);
            wave.scale.set(scaleFactor, 1, scaleFactor);
            
            // Add slight vertical oscillation
            wave.position.y = 0.1 + Math.sin(wave.userData.distance * 0.2) * 0.1;
            
            // Slowly fade out
            const fadeFactor = 1 - (wave.userData.distance / wave.userData.maxDistance);
            wave.userData.opacity = 0.8 * fadeFactor;
            
            // Update material opacity
            wave.children.forEach(child => {
                if (child.material && child.material.opacity !== undefined) {
                    child.material.opacity = wave.userData.opacity;
                }
            });
            
            // Check if wave has reached player
            if (wave.position.distanceTo(camera.position) < 2 * scaleFactor) {
                // Apply damage
                playerHealth -= 20;
                document.getElementById('health').textContent = `Health: ${Math.floor(playerHealth)}`;
                
                // Create screen effect to show damage
                createDamageFlash(0x00FFFF, 0.3); // Cyan flash
                
                // Check for game over
                if (playerHealth <= 0) {
                    gameOver();
                }
                
                // Remove wave that hit player
                scene.remove(wave);
                const index = waveMeshes.indexOf(wave);
                if (index > -1) {
                    waveMeshes.splice(index, 1);
                }
            }
            // Remove if exceeded max distance
            else if (wave.userData.distance >= wave.userData.maxDistance) {
                scene.remove(wave);
                const index = waveMeshes.indexOf(wave);
                if (index > -1) {
                    waveMeshes.splice(index, 1);
                }
            } else {
                stillActive = true;
            }
        });
        
        // Continue animation if any waves are still active
        if (stillActive && !isGameOver) {
            requestAnimationFrame(animateWave);
        }
    }
    
    // Start animation
    animateWave();
}

// Create a screen flash effect for damage
function createDamageFlash(color, intensity) {
    const flash = document.createElement('div');
    flash.style.position = 'absolute';
    flash.style.top = '0';
    flash.style.left = '0';
    flash.style.width = '100%';
    flash.style.height = '100%';
    flash.style.backgroundColor = `rgba(${color >> 16}, ${(color >> 8) & 0xFF}, ${color & 0xFF}, ${intensity})`;
    flash.style.pointerEvents = 'none';
    flash.style.zIndex = '1000';
    flash.style.transition = 'opacity 0.5s';
    
    document.body.appendChild(flash);
    
    // Fade out and remove
    setTimeout(() => {
        flash.style.opacity = '0';
        setTimeout(() => {
            if (flash.parentNode) {
                document.body.removeChild(flash);
            }
        }, 500);
    }, 100);
}

// Play chainsaw slam sound effect
function playChainsawSlamSound() {
    if (audioContext) {
        // Create oscillator for chainsaw motor sound
        const oscillator = audioContext.createOscillator();
        oscillator.type = 'sawtooth';
        oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(20, audioContext.currentTime + 1.0);
        
        // Add noise for chainsaw blade sound
        const noiseNode = audioContext.createBufferSource();
        const bufferSize = audioContext.sampleRate;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        
        noiseNode.buffer = buffer;
        noiseNode.loop = true;
        
        // Create gain nodes for volume control
        const oscillatorGain = audioContext.createGain();
        oscillatorGain.gain.setValueAtTime(0.3, audioContext.currentTime);
        oscillatorGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.0);
        
        const noiseGain = audioContext.createGain();
        noiseGain.gain.setValueAtTime(0.2, audioContext.currentTime);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.0);
        
        // Connect the nodes
        oscillator.connect(oscillatorGain);
        noiseNode.connect(noiseGain);
        oscillatorGain.connect(audioContext.destination);
        noiseGain.connect(audioContext.destination);
        
        // Start and stop
        oscillator.start();
        noiseNode.start();
        
        oscillator.stop(audioContext.currentTime + 1.0);
        noiseNode.stop(audioContext.currentTime + 1.0);
    }
}

function createResearchFacilityEnvironment() {
    console.log("Creating Research Facility Environment...");

    // Ground Plane (dark, wet look)
    const groundSize = 200;
    const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a, // Dark grey/brown
        roughness: 0.6,
        metalness: 0.3, // Slight sheen for wet look
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    ground.name = "environment_ground"; // Add name for cleanup
    scene.add(ground);

    // Main Building (Simplified Box Structure)
    const buildingMaterial = new THREE.MeshStandardMaterial({ color: 0x4d5357, roughness: 0.8 });
    const buildingGroup = new THREE.Group();
    buildingGroup.name = "environment_building";

    const mainBlockGeo = new THREE.BoxGeometry(30, 25, 20);
    const mainBlock = new THREE.Mesh(mainBlockGeo, buildingMaterial);
    mainBlock.position.set(0, 12.5, -20);
    buildingGroup.add(mainBlock);

    const sideBlockGeo = new THREE.BoxGeometry(15, 15, 15);
    const sideBlock = new THREE.Mesh(sideBlockGeo, buildingMaterial);
    sideBlock.position.set(-22.5, 7.5, -17.5);
    buildingGroup.add(sideBlock);

    const entranceBlockGeo = new THREE.BoxGeometry(8, 10, 8);
    const entranceBlock = new THREE.Mesh(entranceBlockGeo, buildingMaterial);
    entranceBlock.position.set(19, 5, -14);
    buildingGroup.add(entranceBlock);

    // Placeholder for Biohazard sign (using CSS or simple texture later if needed)
    // Placeholder for "RESEARCH FACILITY" text

    scene.add(buildingGroup);

    // Watchtower (Simplified)
    const towerGroup = new THREE.Group();
    towerGroup.name = "environment_tower";
    const towerHeight = 30;
    const towerBaseGeo = new THREE.CylinderGeometry(2, 3, towerHeight * 0.8, 4); // Square base
    const towerMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7 });
    const towerBase = new THREE.Mesh(towerBaseGeo, towerMaterial);
    towerBase.position.set(-40, towerHeight * 0.4, -15);
    towerGroup.add(towerBase);

    const towerTopGeo = new THREE.BoxGeometry(6, 4, 6);
    const towerTop = new THREE.Mesh(towerTopGeo, buildingMaterial); // Use building material
    towerTop.position.set(-40, towerHeight - 2, -15);
    towerGroup.add(towerTop);

    // Tower light
    const towerLight = new THREE.PointLight(0xffaa44, 1, 15);
    towerLight.position.set(-40, towerHeight - 1, -15);
    towerGroup.add(towerLight);

    scene.add(towerGroup);

    // Fence (Simplified)
    const fenceGroup = new THREE.Group();
    fenceGroup.name = "environment_fence";
    const fenceMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.6, metalness: 0.4 });
    const postGeo = new THREE.CylinderGeometry(0.2, 0.2, 4, 8);
    const wireGeo = new THREE.PlaneGeometry(10, 3.5); // Represents a section of fence wire
    const wireMaterial = new THREE.MeshBasicMaterial({ color: 0x666666, wireframe: true, side: THREE.DoubleSide });

    for (let i = 0; i < 5; i++) {
        const post = new THREE.Mesh(postGeo, fenceMaterial);
        post.position.set(15 + i * 10, 2, 5);
        fenceGroup.add(post);
        if (i < 4) {
            const wire = new THREE.Mesh(wireGeo, wireMaterial);
            wire.position.set(15 + i * 10 + 5, 1.75, 5);
            fenceGroup.add(wire);
        }
    }
     // Gate post
    const gatePost = new THREE.Mesh(postGeo, fenceMaterial);
    gatePost.position.set(15 + 4 * 10, 2, 5);
    fenceGroup.add(gatePost);
    // Gate Area (just a gap for now)

    scene.add(fenceGroup);


    // Helicopter (Very Simplified Placeholder)
    const heliGroup = new THREE.Group();
    heliGroup.name = "environment_helicopter";
    const heliBodyGeo = new THREE.BoxGeometry(12, 4, 5);
    const heliMaterial = new THREE.MeshStandardMaterial({color: 0x3b4d3b, roughness: 0.7});
    const heliBody = new THREE.Mesh(heliBodyGeo, heliMaterial);
    heliBody.position.set(-25, 2, 15);
    heliGroup.add(heliBody);
    const heliTailGeo = new THREE.BoxGeometry(8, 1.5, 1.5);
    const heliTail = new THREE.Mesh(heliTailGeo, heliMaterial);
    heliTail.position.set(-31, 3, 15);
    heliGroup.add(heliTail);
    // Add simple rotor placeholder if desired
    scene.add(heliGroup);

    // Trees (Simplified Cones/Cylinders)
    const treeGroup = new THREE.Group();
    treeGroup.name = "environment_trees";
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3b2a });
    const leavesMat = new THREE.MeshStandardMaterial({ color: 0x2a3b2a });
    for (let i = 0; i < 20; i++) {
        const trunkGeo = new THREE.CylinderGeometry(0.5, 0.8, 8 + Math.random() * 10, 8);
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        const leavesGeo = new THREE.ConeGeometry(3 + Math.random()*2, 10 + Math.random() * 5, 8);
        const leaves = new THREE.Mesh(leavesGeo, leavesMat);

        const tree = new THREE.Group();
        trunk.position.y = trunk.geometry.parameters.height / 2;
        leaves.position.y = trunk.geometry.parameters.height + leaves.geometry.parameters.height / 2 - 2;
        tree.add(trunk);
        tree.add(leaves);

        // Random positions around the edges
        const angle = Math.random() * Math.PI * 2;
        const radius = 60 + Math.random() * 30;
        tree.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
        treeGroup.add(tree);
    }
    scene.add(treeGroup);


    // Lighting (Night Time)
    scene.remove(ambientLight); // Remove previous ambient light if it exists globally
    ambientLight = new THREE.AmbientLight(0x1a2a3a, 0.4); // Dark blue ambient
    ambientLight.name = "environment_light_ambient";
    scene.add(ambientLight);

    const moonLight = new THREE.DirectionalLight(0xadc8ff, 0.6); // Pale blue moonlight
    moonLight.position.set(-50, 80, -30);
    moonLight.name = "environment_light_moon";
    // Optional: Add shadows
    // moonLight.castShadow = true;
    // moonLight.shadow.mapSize.width = 1024;
    // moonLight.shadow.mapSize.height = 1024;
    scene.add(moonLight);

    // Entrance light
    const entranceLight = new THREE.PointLight(0xffcc66, 1, 20);
    entranceLight.position.set(19, 8, -10);
    entranceLight.name = "environment_light_entrance";
    scene.add(entranceLight);

    // Fog
    scene.fog = new THREE.Fog(0x0a1a2a, 50, 150); // Dark blue fog

    // Sky (Optional - simple gradient or texture)
    // scene.background = new THREE.Color(0x051020); // Dark night sky color
    // Or use a CubeTextureLoader for a skybox if you have images
}

function clearEnvironment() {
    console.log("Clearing previous environment...");
    const objectsToRemove = [];
    scene.traverse((object) => {
        // Check for names assigned to environment parts
        if (object.name && object.name.startsWith("environment_")) {
            objectsToRemove.push(object);
        }
        // Check if it's a regular zombie (assuming they are in the 'zombies' array and are Groups/Meshes)
        else if (zombies.includes(object) && object !== bossZombie) {
             objectsToRemove.push(object);
        }
        // You might need more specific checks based on how Round 1 was built
        // e.g., if ground was named 'ground', etc.
        else if (object.name === 'ground_plane_round1') { // Example name
             objectsToRemove.push(object);
        }
    });

    objectsToRemove.forEach(object => {
        // Remove from parent (usually the scene)
        if (object.parent) {
            object.parent.remove(object);
        }
        // Dispose geometry and material to free memory (important!)
        if (object.geometry) object.geometry.dispose();
        if (object.material) {
            if (Array.isArray(object.material)) {
                object.material.forEach(mat => mat.dispose());
            } else {
                object.material.dispose();
            }
        }
    });

    // Clear zombie array (excluding potential boss reference if needed elsewhere)
    zombies.length = 0; // Reset the zombie tracking array
    // Clear other relevant arrays (projectiles, etc.)
    bullets.forEach(b => scene.remove(b)); bullets.length = 0;
    poisonProjectiles.forEach(p => scene.remove(p)); poisonProjectiles.length = 0;


    // Reset fog if necessary
    scene.fog = null;
    // Reset background if necessary
    // scene.background = null;

     // Remove specific lights if they were added globally and named
    const lightToRemoveMoon = scene.getObjectByName("environment_light_moon");
    if(lightToRemoveMoon) scene.remove(lightToRemoveMoon);
     const lightToRemoveAmbient = scene.getObjectByName("environment_light_ambient");
    if(lightToRemoveAmbient) scene.remove(lightToRemoveAmbient);
     const lightToRemoveEntrance = scene.getObjectByName("environment_light_entrance");
    if(lightToRemoveEntrance) scene.remove(lightToRemoveEntrance);

    // You might need to specifically remove Round 1 lights/objects if not named
}

function showRoundText(roundNumber, duration = 3000, onComplete = null) {
    // Remove any existing round text/overlay first
    const existingText = document.getElementById('roundText');
    const existingOverlay = document.getElementById('roundOverlay');
    if (existingText) document.body.removeChild(existingText);
    if (existingOverlay) document.body.removeChild(existingOverlay);

    // Create overlay div
    const overlayDiv = document.createElement('div');
    overlayDiv.id = 'roundOverlay';
    overlayDiv.style.position = 'absolute';
    overlayDiv.style.top = '0';
    overlayDiv.style.left = '0';
    overlayDiv.style.width = '100%';
    overlayDiv.style.height = '100%';
    overlayDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.7)'; // Dark semi-transparent
    overlayDiv.style.backdropFilter = 'blur(8px)'; // Apply blur
    overlayDiv.style.webkitBackdropFilter = 'blur(8px)'; // For Safari
    overlayDiv.style.zIndex = '999'; // Below text
    overlayDiv.style.opacity = '0';
    overlayDiv.style.transition = 'opacity 1s ease-in';
    document.body.appendChild(overlayDiv);

    // Create text div (using previous styling)
    const roundTextDiv = document.createElement('div');
    roundTextDiv.id = 'roundText';
    // --- Paste the styles from your previous round text function here ---
    roundTextDiv.style.position = 'absolute';
    roundTextDiv.style.top = '50%';
    roundTextDiv.style.left = '50%';
    roundTextDiv.style.transform = 'translate(-50%, -50%) scale(0.8)'; // Start slightly smaller
    roundTextDiv.style.fontSize = '8em';
    roundTextDiv.style.fontFamily = 'Arial, sans-serif';
    roundTextDiv.style.fontWeight = 'bold';
    roundTextDiv.style.color = '#c3e2c4'; // Light green color
    roundTextDiv.style.textShadow =
        '0 0 5px #c3e2c4, ' +
        '0 1px 0 #a0d8a2, ' +
        '0 2px 0 #9fd0a0, ' +
        '0 3px 0 #8ec894, ' +
        '0 4px 0 #7ebd85, ' +
        '0 5px 0 #6eb278, ' +
        '0 6px 0 #5da76c, ' +
        '0 7px 0 #4d9c61, ' +
        '0 8px 7px rgba(0, 0, 0, 0.4)';
    roundTextDiv.style.letterSpacing = '10px';
    roundTextDiv.style.textAlign = 'center';
    roundTextDiv.style.zIndex = '1000'; // Above overlay
    roundTextDiv.style.pointerEvents = 'none';
    roundTextDiv.style.opacity = '0';
    roundTextDiv.style.transition = 'opacity 1s ease-in, transform 1s ease-out';
    // --- End of pasted styles ---
    roundTextDiv.textContent = `ROUND ${roundNumber}`;
    document.body.appendChild(roundTextDiv);

    // Animate in
    setTimeout(() => {
        overlayDiv.style.opacity = '1';
        roundTextDiv.style.opacity = '1';
        roundTextDiv.style.transform = 'translate(-50%, -50%) scale(1)';

        // Hold, then animate out
        setTimeout(() => {
            overlayDiv.style.opacity = '0';
            roundTextDiv.style.opacity = '0';
            roundTextDiv.style.transform = 'translate(-50%, -50%) scale(1.5)'; // Scale out

            // Remove after animation & call callback
            setTimeout(() => {
                if (overlayDiv.parentNode) document.body.removeChild(overlayDiv);
                if (roundTextDiv.parentNode) document.body.removeChild(roundTextDiv);
                if (onComplete) onComplete(); // Execute the callback
            }, 1000); // Wait for fade out transition (1s)
        }, duration); // Use the passed duration (e.g., 15000ms)
    }, 100); // Short delay to ensure transition works
}


    </script>
    <script src="poison-functions.js"></script>
</body>
</html>